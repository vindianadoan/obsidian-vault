/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TagFolderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian6 = require("obsidian");

// types.ts
var DEFAULT_SETTINGS = {
  displayMethod: "NAME",
  alwaysOpen: false,
  ignoreDocTags: "",
  ignoreTags: "",
  hideOnRootTags: "",
  sortType: "DISPNAME_ASC",
  sortTypeTag: "NAME_ASC",
  expandLimit: 0,
  disableNestedTags: false,
  hideItems: "NONE",
  ignoreFolders: "",
  targetFolders: "",
  scanDelay: 250,
  useTitle: true,
  reduceNestedParent: true,
  frontmatterKey: "title",
  useTagInfo: false,
  tagInfo: "pininfo.md",
  mergeRedundantCombination: false,
  useVirtualTag: false,
  doNotSimplifyTags: false,
  overrideTagClicking: false,
  useMultiPaneList: false,
  archiveTags: "",
  disableNarrowingDown: false,
  expandUntaggedToRoot: false
};
var VIEW_TYPE_SCROLL = "tagfolder-view-scroll";
var EPOCH_MINUTE = 60;
var EPOCH_HOUR = EPOCH_MINUTE * 60;
var EPOCH_DAY = EPOCH_HOUR * 24;
var FRESHNESS_1 = "FRESHNESS_01";
var FRESHNESS_2 = "FRESHNESS_02";
var FRESHNESS_3 = "FRESHNESS_03";
var FRESHNESS_4 = "FRESHNESS_04";
var FRESHNESS_5 = "FRESHNESS_05";
var tagDispDict = {
  FRESHNESS_01: "\u{1F550}",
  FRESHNESS_02: "\u{1F4D6}",
  FRESHNESS_03: "\u{1F4D7}",
  FRESHNESS_04: "\u{1F4DA}",
  FRESHNESS_05: "\u{1F5C4}",
  _VIRTUAL_TAG_FRESHNESS: "\u231B",
  _VIRTUAL_TAG_CANVAS: "\u{1F4CB} Canvas"
};
var VIEW_TYPE_TAGFOLDER = "tagfolder-view";
var VIEW_TYPE_TAGFOLDER_LIST = "tagfolder-view-list";
var OrderKeyTag = {
  NAME: "Tag name",
  ITEMS: "Count of items"
};
var OrderDirection = {
  ASC: "Ascending",
  DESC: "Descending"
};
var OrderKeyItem = {
  DISPNAME: "Displaying name",
  NAME: "File name",
  MTIME: "Modified time",
  CTIME: "Created time",
  FULLPATH: "Fullpath of the file"
};

// node_modules/svelte/internal/index.mjs
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
var HtmlTag = class {
  constructor(is_svg = false) {
    this.is_svg = false;
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  c(html) {
    this.h(html);
  }
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(target.nodeName);
      else
        this.e = element(target.nodeType === 11 ? "TEMPLATE" : target.nodeName);
      this.t = target.tagName !== "TEMPLATE" ? target : target.content;
      this.c(html);
    }
    this.i(anchor);
  }
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes);
  }
  i(anchor) {
    for (let i = 0; i < this.n.length; i += 1) {
      insert(this.t, this.n[i], anchor);
    }
  }
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  d() {
    this.n.forEach(detach);
  }
};
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function afterUpdate(fn) {
  get_current_component().$$.after_update.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance7, create_fragment7, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment7 ? create_fragment7($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}

// store.ts
var currentFile = writable("");
var maxDepth = writable(0);
var searchString = writable("");
var tagInfo = writable({});
var tagFolderSetting = writable(DEFAULT_SETTINGS);
var selectedTags = writable();
var allViewItems = writable();
var v2expandedTags = writable(/* @__PURE__ */ new Set());

// util.ts
function unique(items) {
  return [.../* @__PURE__ */ new Set([...items])];
}
function trimSlash(src, keepStart = false, keepEnd = false) {
  const st = keepStart ? 0 : src[0] == "/" ? 1 : 0;
  const end = keepEnd ? void 0 : src.endsWith("/") ? -1 : void 0;
  if (st == 0 && end == void 0)
    return src;
  return src.slice(st, end);
}
function ancestorToTags(ancestors) {
  return ancestors.reduce(
    (p, i) => i[0] != "/" ? [...p, i] : [
      ...p,
      p.pop() + "/" + i.substring(1)
    ],
    []
  );
}
function ancestorToLongestTag(ancestors) {
  return ancestors.reduceRight((a, e) => {
    var _a;
    return !a ? [e] : ((_a = a[0]) == null ? void 0 : _a.startsWith(e)) ? a : [e, ...a];
  }, []);
}
function isSpecialTag(tagSrc) {
  const tag = trimSlash(tagSrc);
  return tag == "_untagged" || tag in tagDispDict;
}
var tagDispAlternativeDict = {};
tagInfo.subscribe((tagInfo2) => {
  tagDispAlternativeDict = { ...tagDispDict };
  if (tagInfo2 == null) {
    return;
  }
  const items = Object.entries(tagInfo2);
  for (const [key, info] of items) {
    if ("alt" in info) {
      tagDispAlternativeDict[key] = info.alt;
    }
  }
});
function renderSpecialTag(tagSrc) {
  const tag = trimSlash(tagSrc);
  return tag in tagDispAlternativeDict ? tagDispAlternativeDict[tag] : tagSrc;
}
function secondsToFreshness(totalAsMSec) {
  const totalAsSec = ~~(totalAsMSec / 1e3);
  const sign = totalAsSec / Math.abs(totalAsSec);
  const totalSec = ~~(totalAsSec * sign);
  if (totalSec < EPOCH_HOUR)
    return FRESHNESS_1;
  if (totalSec < EPOCH_HOUR * 6)
    return FRESHNESS_2;
  if (totalSec < EPOCH_DAY * 3)
    return FRESHNESS_3;
  if (totalSec < EPOCH_DAY * 7)
    return FRESHNESS_4;
  return FRESHNESS_5;
}
var queues = [];
function waitForRequestAnimationFrame() {
  return new Promise((res) => requestAnimationFrame(() => res()));
}
function delay() {
  return new Promise((res) => setTimeout(() => res(), 5));
}
var waits = [waitForRequestAnimationFrame, waitForRequestAnimationFrame, delay];
var waitIdx = 0;
var pumping = false;
var startContinuousProcessing = Date.now();
async function pump() {
  if (pumping)
    return;
  try {
    pumping = true;
    do {
      const proc = queues.shift();
      if (proc) {
        proc();
        const now = Date.now();
        if (now - startContinuousProcessing > 120) {
          const w = waits[waitIdx];
          waitIdx = (waitIdx + 1) % waits.length;
          await w();
          startContinuousProcessing = Date.now();
        }
      } else {
        break;
      }
    } while (true);
  } finally {
    pumping = false;
  }
}
var doEvents = () => {
  return new Promise((res) => {
    const proc = () => {
      res();
    };
    queues.push(proc);
    pump();
  });
};
var compare = Intl && Intl.Collator ? new Intl.Collator().compare : (x, y) => `${x != null ? x : ""}`.localeCompare(`${y != null ? y : ""}`);
function getTagName(tagName, subtreePrefix, tagInfo2, invert) {
  if (tagInfo2 == null)
    return tagName;
  const prefix = invert == -1 ? `\uFFFF` : ``;
  const unpinned = invert == 1 ? `\uFFFF` : ``;
  if (tagName in tagInfo2 && tagInfo2[tagName]) {
    if ("key" in tagInfo2[tagName]) {
      return `${prefix}_-${tagInfo2[tagName].key}__${subtreePrefix}_${tagName}`;
    }
  }
  return `${prefix}_${unpinned}_${subtreePrefix}_${tagName}`;
}
function llc(str) {
  return str.toLocaleLowerCase();
}
function removeIntermediatePath(paths) {
  const out = [...paths];
  const pathEntries = paths.sort((a, b) => a.length - b.length);
  const removeList = [];
  for (const el of pathEntries) {
    const elLower = llc(el);
    const elCapped = elLower.endsWith("/") ? elLower : elLower + "/";
    if (out.some((e) => llc(e).startsWith(elCapped) && llc(e) !== elCapped)) {
      removeList.push(el);
    }
  }
  return out.filter((e) => removeList.indexOf(e) == -1);
}
function getTagMark(tagInfo2) {
  if (!tagInfo2)
    return "";
  if ("key" in tagInfo2) {
    if ("mark" in tagInfo2 && tagInfo2.mark != "") {
      return tagInfo2.mark;
    } else {
      return "\u{1F4CC}";
    }
  } else {
    if ("mark" in tagInfo2 && tagInfo2.mark != "") {
      return tagInfo2.mark;
    } else {
      return "";
    }
  }
}
function escapeStringToHTML(str) {
  if (!str)
    return "";
  return str.replace(/[<>&"'`]/g, (match) => {
    const escape = {
      "<": "&lt;",
      ">": "&gt;",
      "&": "&amp;",
      '"': "&quot;",
      "'": "&#39;",
      "`": "&#x60;"
    };
    return escape[match];
  });
}
var V2FI_IDX_TAG = 0;
var V2FI_IDX_TAGNAME = 1;
var V2FI_IDX_TAGDISP = 2;
var V2FI_IDX_CHILDREN = 3;
function selectCompareMethodTags(settings, tagInfo2) {
  const _tagInfo = tagInfo2;
  const invert = settings.sortTypeTag.contains("_DESC") ? -1 : 1;
  const subTreeChar = {
    [-1]: `\u{10FFFF}`,
    [1]: `_`
  };
  const sortByName = (a, b) => {
    const isASubTree = a[V2FI_IDX_TAG].endsWith("/" + a[V2FI_IDX_TAGNAME]);
    const isBSubTree = b[V2FI_IDX_TAG].endsWith("/" + b[V2FI_IDX_TAGNAME]);
    const aName = a[V2FI_IDX_TAGNAME];
    const bName = b[V2FI_IDX_TAGNAME];
    const aPrefix = isASubTree ? subTreeChar[invert] : "";
    const bPrefix = isBSubTree ? subTreeChar[invert] : "";
    return compare(getTagName(aName, aPrefix, settings.useTagInfo ? _tagInfo : null, invert), getTagName(bName, bPrefix, settings.useTagInfo ? _tagInfo : null, invert)) * invert;
  };
  switch (settings.sortTypeTag) {
    case "ITEMS_ASC":
    case "ITEMS_DESC":
      return (a, b) => {
        const aName = a[V2FI_IDX_TAGNAME];
        const bName = b[V2FI_IDX_TAGNAME];
        const aCount = a[V2FI_IDX_CHILDREN].length - (settings.useTagInfo && (aName in _tagInfo && "key" in _tagInfo[aName]) ? 1e5 * invert : 0);
        const bCount = b[V2FI_IDX_CHILDREN].length - (settings.useTagInfo && (bName in _tagInfo && "key" in _tagInfo[bName]) ? 1e5 * invert : 0);
        if (aCount == bCount)
          return sortByName(a, b);
        return (aCount - bCount) * invert;
      };
    case "NAME_ASC":
    case "NAME_DESC":
      return sortByName;
    default:
      console.warn("Compare method (tags) corrupted");
      return (a, b) => {
        const isASubTree = a[V2FI_IDX_TAG].endsWith("/" + a[V2FI_IDX_TAGNAME]);
        const isBSubTree = b[V2FI_IDX_TAG].endsWith("/" + b[V2FI_IDX_TAGNAME]);
        const aName = a[V2FI_IDX_TAGNAME];
        const bName = b[V2FI_IDX_TAGNAME];
        const aPrefix = isASubTree ? subTreeChar[invert] : "";
        const bPrefix = isBSubTree ? subTreeChar[invert] : "";
        return compare(aPrefix + aName, bPrefix + bName) * invert;
      };
  }
}
function uniqueCaseIntensive(pieces) {
  const delMap = /* @__PURE__ */ new Set();
  const ret = [];
  for (const piece of pieces) {
    if (!delMap.has(piece.toLocaleLowerCase())) {
      ret.push(piece);
      delMap.add(piece.toLocaleLowerCase());
    }
  }
  return ret;
}
function _sorterTagLength(a, b, invert) {
  const lenA = a.split("/").length;
  const lenB = b.split("/").length;
  const diff = lenA - lenB;
  if (diff != 0)
    return diff * (invert ? -1 : 1);
  return (a.length - b.length) * (invert ? -1 : 1);
}
function getExtraTags(tags, trail, reduceNestedParent) {
  let tagsLeft = uniqueCaseIntensive(tags);
  let removeTrailItems = [];
  if (reduceNestedParent) {
    removeTrailItems = trail.sort((a, b) => _sorterTagLength(a, b, true));
  } else {
    removeTrailItems = removeIntermediatePath(trail);
  }
  for (const t of removeTrailItems) {
    const inDedicatedTree = t.endsWith("/");
    const trimLength = inDedicatedTree ? t.length : t.length;
    if (reduceNestedParent) {
      tagsLeft = tagsLeft.map(
        (e) => (e + "/").toLocaleLowerCase().startsWith(t.toLocaleLowerCase()) ? e.substring(trimLength) : e
      );
    } else {
      const f = tagsLeft.findIndex(
        (e) => (e + "/").toLocaleLowerCase().startsWith(t.toLocaleLowerCase())
      );
      if (f !== -1) {
        tagsLeft[f] = tagsLeft[f].substring(trimLength);
      }
    }
  }
  return tagsLeft.filter((e) => e.trim() != "");
}
function trimTrailingSlash(src) {
  return trimSlash(src, true, false);
}
function joinPartialPath(path) {
  return path.reduceRight((p, c) => c.endsWith("/") && p.length > 0 ? [c + p[0], ...p.slice(1)] : [c, ...p], []);
}
function pathMatch(haystack, needle) {
  const haystackLC = haystack.toLocaleLowerCase();
  const needleLC = needle.toLocaleLowerCase();
  if (needleLC.endsWith("/")) {
    if ((haystackLC + "/").indexOf(needleLC) === 0)
      return true;
  }
  return haystackLC == needleLC;
}
function parseTagName(thisName, _tagInfo) {
  let tagNameDisp = [""];
  const names = thisName.split("/").filter((e) => e.trim() != "");
  let inSubTree = false;
  let tagName = "";
  if (names.length > 1) {
    tagName = `${names[names.length - 1]}`;
    inSubTree = true;
  } else {
    tagName = thisName;
  }
  if (tagName.endsWith("/")) {
    tagName = tagName.substring(0, tagName.length - 1);
  }
  const tagInfo2 = tagName in _tagInfo ? _tagInfo[tagName] : void 0;
  const tagMark = getTagMark(tagInfo2);
  tagNameDisp = [`${tagMark}${renderSpecialTag(tagName)}`];
  if (inSubTree)
    tagNameDisp = [`${tagMark}`, `${renderSpecialTag(tagName)}`];
  return [tagName, tagNameDisp];
}

// ScrollView.ts
var import_obsidian2 = require("obsidian");

// ScrollViewMarkdownComponent.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1qfikme", ".markdownBody.svelte-1qfikme{user-select:text;-webkit-user-select:text}");
}
function create_fragment(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "markdownBody svelte-1qfikme");
      set_style(div, "min-height", "1em");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { file = { path: "" } } = $$props;
  let { observer } = $$props;
  let el;
  let renderedContent = "";
  function onAppearing(_) {
    if (file.content && el && renderedContent != file.content) {
      import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
      $$invalidate(3, renderedContent = file.content);
    }
  }
  onMount(() => {
    observer.observe(el);
    el.addEventListener("appearing", onAppearing);
  });
  onDestroy(() => {
    observer.unobserve(el);
    el.removeEventListener("appearing", onAppearing);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el), $$invalidate(3, renderedContent), $$invalidate(1, file);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("file" in $$props2)
      $$invalidate(1, file = $$props2.file);
    if ("observer" in $$props2)
      $$invalidate(2, observer = $$props2.observer);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*renderedContent, file, el*/
    11) {
      $: {
        if (renderedContent && file && file.content && el && renderedContent != file.content) {
          $$invalidate(0, el.style.minHeight = `${el.clientHeight}px`, el);
          $$invalidate(0, el.innerHTML = "", el);
          import_obsidian.MarkdownRenderer.renderMarkdown(file.content, el, file.path, null);
          $$invalidate(3, renderedContent = file.content);
          $$invalidate(0, el.style.minHeight = "20px", el);
        }
      }
    }
  };
  return [el, file, observer, renderedContent, div_binding];
}
var ScrollViewMarkdownComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { file: 1, observer: 2 }, add_css);
  }
};
var ScrollViewMarkdownComponent_default = ScrollViewMarkdownComponent;

// ScrollViewComponent.svelte
function add_css2(target) {
  append_styles(target, "svelte-s1mg0b", ".header.svelte-s1mg0b{background-color:var(--background-secondary-alt);position:sticky;top:0;color:var(--text-normal);margin-bottom:8px}.file.svelte-s1mg0b{cursor:pointer}.path.svelte-s1mg0b{font-size:75%}hr.svelte-s1mg0b{margin:8px auto}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div1;
  let div0;
  let span0;
  let t0_value = (
    /*file*/
    ctx[11].title + ""
  );
  let t0;
  let t1;
  let span1;
  let t2;
  let t3_value = (
    /*file*/
    ctx[11].path + ""
  );
  let t3;
  let t4;
  let t5;
  let scrollviewmarkdown;
  let t6;
  let hr;
  let t7;
  let current;
  let mounted;
  let dispose;
  scrollviewmarkdown = new ScrollViewMarkdownComponent_default({
    props: {
      file: (
        /*file*/
        ctx[11]
      ),
      observer: (
        /*observer*/
        ctx[1]
      )
    }
  });
  function click_handler(...args) {
    return (
      /*click_handler*/
      ctx[8](
        /*file*/
        ctx[11],
        ...args
      )
    );
  }
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      t2 = text("(");
      t3 = text(t3_value);
      t4 = text(")");
      t5 = space();
      create_component(scrollviewmarkdown.$$.fragment);
      t6 = space();
      hr = element("hr");
      t7 = space();
      attr(span1, "class", "path svelte-s1mg0b");
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "file svelte-s1mg0b");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(div0, t1);
      append(div0, span1);
      append(span1, t2);
      append(span1, t3);
      append(span1, t4);
      append(div1, t5);
      mount_component(scrollviewmarkdown, div1, null);
      append(div1, t6);
      append(div1, hr);
      append(div1, t7);
      ctx[9](div1);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty & /*files*/
      8) && t0_value !== (t0_value = /*file*/
      ctx[11].title + ""))
        set_data(t0, t0_value);
      if ((!current || dirty & /*files*/
      8) && t3_value !== (t3_value = /*file*/
      ctx[11].path + ""))
        set_data(t3, t3_value);
      const scrollviewmarkdown_changes = {};
      if (dirty & /*files*/
      8)
        scrollviewmarkdown_changes.file = /*file*/
        ctx[11];
      if (dirty & /*observer*/
      2)
        scrollviewmarkdown_changes.observer = /*observer*/
        ctx[1];
      scrollviewmarkdown.$set(scrollviewmarkdown_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(scrollviewmarkdown.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(scrollviewmarkdown.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(scrollviewmarkdown);
      ctx[9](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment2(ctx) {
  let div1;
  let div0;
  let t0;
  let t1;
  let t2;
  let hr;
  let t3;
  let current;
  let each_value = (
    /*files*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text("Files with ");
      t1 = text(
        /*tagPath*/
        ctx[2]
      );
      t2 = space();
      hr = element("hr");
      t3 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div0, "class", "header svelte-s1mg0b");
      attr(hr, "class", "svelte-s1mg0b");
      attr(div1, "class", "x");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div0, t1);
      append(div1, t2);
      append(div1, hr);
      append(div1, t3);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*tagPath*/
      4)
        set_data(
          t1,
          /*tagPath*/
          ctx2[2]
        );
      if (dirty & /*scrollEl, handleOpenFile, files, observer*/
      27) {
        each_value = /*files*/
        ctx2[3];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let files;
  let tagPath;
  let { store = writable({ files: [], title: "", tagPath: "" }) } = $$props;
  let { openfile } = $$props;
  let state = { files: [], title: "", tagPath: "" };
  function handleOpenFile(e, file) {
    openfile(file.path, false);
    e.preventDefault();
  }
  let scrollEl;
  let observer;
  const onAppearing = new CustomEvent("appearing", { detail: {} });
  onMount(() => {
    const options = {
      root: scrollEl,
      rootMargin: "10px",
      threshold: 0
    };
    $$invalidate(1, observer = new IntersectionObserver(
      (entries) => {
        for (const entry of entries) {
          if (entry.isIntersecting) {
            entry.target.dispatchEvent(onAppearing);
          }
        }
      },
      options
    ));
  });
  onDestroy(() => {
    observer.disconnect();
  });
  const click_handler = (file, evt) => handleOpenFile(evt, file);
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollEl = $$value;
      $$invalidate(0, scrollEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("store" in $$props2)
      $$invalidate(5, store = $$props2.store);
    if ("openfile" in $$props2)
      $$invalidate(6, openfile = $$props2.openfile);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*store*/
    32) {
      $: {
        store.subscribe((_state) => {
          $$invalidate(7, state = { ..._state });
          return () => {
          };
        });
      }
    }
    if ($$self.$$.dirty & /*state*/
    128) {
      $:
        $$invalidate(3, files = state.files);
    }
    if ($$self.$$.dirty & /*state*/
    128) {
      $:
        $$invalidate(2, tagPath = state.tagPath.split(", ").map((e) => "#" + trimTrailingSlash(e).split("/").map((e2) => renderSpecialTag(e2.trim())).join("/")).join(", "));
    }
  };
  return [
    scrollEl,
    observer,
    tagPath,
    files,
    handleOpenFile,
    store,
    openfile,
    state,
    click_handler,
    div1_binding
  ];
}
var ScrollViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { store: 5, openfile: 6 }, add_css2);
  }
};
var ScrollViewComponent_default = ScrollViewComponent;

// ScrollView.ts
var ScrollView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { files: [], title: "", tagPath: "" };
    this.plugin = plugin;
    this.store = writable({ files: [], title: "", tagPath: "" });
  }
  getIcon() {
    return "sheets-in-box";
  }
  getViewType() {
    return VIEW_TYPE_SCROLL;
  }
  getDisplayText() {
    return this.state.tagPath || "Tags scroll";
  }
  async setFile(filenames) {
    this.state = { ...this.state, files: filenames };
    await this.updateView();
  }
  async setState(state, result) {
    this.state = { ...state };
    this.title = state.title;
    await this.updateView();
    result = {};
    return;
  }
  getState() {
    return this.state;
  }
  isFileOpened(path) {
    return this.state.files.some((e) => e.path == path);
  }
  getScrollViewState() {
    return this.state;
  }
  async updateView() {
    const items = [];
    for (const item of this.state.files) {
      if (item.content) {
        items.push(item);
      } else {
        const f = this.app.vault.getAbstractFileByPath(item.path);
        if (f == null || !(f instanceof import_obsidian2.TFile)) {
          console.log(`File not found:${item.path}`);
          items.push(item);
          continue;
        }
        const title = this.plugin.getFileTitle(f);
        const w = await this.app.vault.read(f);
        await doEvents();
        item.content = w;
        item.title = title;
        items.push(item);
      }
    }
    this.state = { ...this.state, files: [...items] };
    this.store.set(this.state);
  }
  async onOpen() {
    this.component = new ScrollViewComponent_default({
      target: this.contentEl,
      props: {
        store: this.store,
        openfile: this.plugin.focusFile
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// V2TreeItemComponent.svelte
function create_fragment3(ctx) {
  let div1;
  let div0;
  let t0_value = (
    /*item*/
    ctx[0].displayName + ""
  );
  let t0;
  let t1;
  let html_tag;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      html_tag = new HtmlTag(false);
      attr(div0, "class", "tree-item-inner nav-file-title-content lsl-f");
      html_tag.a = null;
      attr(div1, "class", "tree-item-self is-clickable nav-file-title");
      toggle_class(
        div1,
        "is-active",
        /*isActive*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, t0);
      append(div1, t1);
      html_tag.m(
        /*extraTagsHtml*/
        ctx[4],
        div1
      );
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "click",
            /*click_handler*/
            ctx[10]
          ),
          listen(
            div1,
            "mouseover",
            /*mouseover_handler*/
            ctx[11]
          ),
          listen(div1, "focus", focus_handler),
          listen(
            div1,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[12]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && t0_value !== (t0_value = /*item*/
      ctx2[0].displayName + ""))
        set_data(t0, t0_value);
      if (dirty & /*extraTagsHtml*/
      16)
        html_tag.p(
          /*extraTagsHtml*/
          ctx2[4]
        );
      if (dirty & /*isActive*/
      32) {
        toggle_class(
          div1,
          "is-active",
          /*isActive*/
          ctx2[5]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
var focus_handler = () => {
};
function instance3($$self, $$props, $$invalidate) {
  let isActive;
  let $tagFolderSetting;
  component_subscribe($$self, tagFolderSetting, ($$value) => $$invalidate(13, $tagFolderSetting = $$value));
  let { item } = $$props;
  let { trail } = $$props;
  let { openFile } = $$props;
  let { showMenu } = $$props;
  let { hoverPreview } = $$props;
  function handleMouseover(e, path) {
    hoverPreview(e, path);
  }
  let _currentActiveFilePath = "";
  let _setting = $tagFolderSetting;
  currentFile.subscribe((path) => {
    $$invalidate(8, _currentActiveFilePath = path);
  });
  tagFolderSetting.subscribe((setting) => {
    $$invalidate(9, _setting = setting);
  });
  let extraTagsHtml = "";
  const click_handler = (evt) => openFile(item.path, evt.metaKey || evt.ctrlKey);
  const mouseover_handler = (e) => {
    handleMouseover(e, item.path);
  };
  const contextmenu_handler = (evt) => showMenu(evt, trail, void 0, [item]);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("trail" in $$props2)
      $$invalidate(1, trail = $$props2.trail);
    if ("openFile" in $$props2)
      $$invalidate(2, openFile = $$props2.openFile);
    if ("showMenu" in $$props2)
      $$invalidate(3, showMenu = $$props2.showMenu);
    if ("hoverPreview" in $$props2)
      $$invalidate(7, hoverPreview = $$props2.hoverPreview);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item, _currentActiveFilePath*/
    257) {
      $:
        $$invalidate(5, isActive = item.path == _currentActiveFilePath);
    }
    if ($$self.$$.dirty & /*item, trail, _setting*/
    515) {
      $: {
        const tagsLeft = uniqueCaseIntensive(getExtraTags(item.tags, [...trail], _setting.reduceNestedParent).map((e) => trimSlash(e, false, true)).filter((e) => e != ""));
        $$invalidate(4, extraTagsHtml = `<div class="tf-taglist">${tagsLeft.map((e) => `<span>${escapeStringToHTML(renderSpecialTag(e))}</span>`).join("")}</div>`);
      }
    }
  };
  return [
    item,
    trail,
    openFile,
    showMenu,
    extraTagsHtml,
    isActive,
    handleMouseover,
    hoverPreview,
    _currentActiveFilePath,
    _setting,
    click_handler,
    mouseover_handler,
    contextmenu_handler
  ];
}
var V2TreeItemComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, {
      item: 0,
      trail: 1,
      openFile: 2,
      showMenu: 3,
      hoverPreview: 7
    });
  }
};
var V2TreeItemComponent_default = V2TreeItemComponent;

// OnDemandRender.svelte
function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "...";
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
    }
  };
}
function create_if_block(ctx) {
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[11].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[10],
    null
  );
  return {
    c() {
      if (default_slot)
        default_slot.c();
    },
    m(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        1024)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[10],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[10]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[10],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function create_fragment4(ctx) {
  let div;
  let current_block_type_index;
  let if_block;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isVisible*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div = element("div");
      if_block.c();
      attr(
        div,
        "class",
        /*cssClass*/
        ctx[2]
      );
      attr(
        div,
        "style",
        /*stylePlaceHolder*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if_blocks[current_block_type_index].m(div, null);
      ctx[12](div);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, null);
      }
      if (!current || dirty & /*cssClass*/
      4) {
        attr(
          div,
          "class",
          /*cssClass*/
          ctx2[2]
        );
      }
      if (!current || dirty & /*stylePlaceHolder*/
      8) {
        attr(
          div,
          "style",
          /*stylePlaceHolder*/
          ctx2[3]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if_blocks[current_block_type_index].d();
      ctx[12](null);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let stylePlaceHolder;
  let cssClass;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { placeHolderClass = "" } = $$props;
  let { wrapperClass = "" } = $$props;
  let { force = false } = $$props;
  let isVisible = force;
  let observer;
  const { getScrollParent } = getContext("tf-list");
  const scrollParent = getScrollParent();
  const observingOption = {
    root: scrollParent,
    rootMargin: "80px 0px",
    threshold: 0
  };
  function startObserving() {
    if (observer) {
      return;
    }
    $$invalidate(7, observer = new IntersectionObserver(
      (ex) => {
        if (ex.some((e) => e.isIntersecting)) {
          $$invalidate(0, isVisible = true);
        } else {
          $$invalidate(0, isVisible = force);
        }
      },
      observingOption
    ));
  }
  function stopObserving() {
    if (observer) {
      observer.disconnect();
      $$invalidate(7, observer = void 0);
    }
  }
  onMount(() => {
    if (el) {
      el.addEventListener("toggled", handleToggled);
    }
    startObserving();
    return () => {
      stopObserving();
      if (el) {
        el.removeEventListener("toggled", handleToggled);
      }
    };
  });
  let _el;
  let el;
  let ch = 0;
  function measureHeight(force2) {
    if (isVisible || force2) {
      const { height } = el.getBoundingClientRect();
      if (ch != height) {
        $$invalidate(9, ch = height);
        el.dispatchEvent(new CustomEvent("toggled", { bubbles: true }));
      }
    }
  }
  function handleToggled(evt) {
    if (evt.target != el) {
      measureHeight(true);
    }
  }
  afterUpdate(async () => {
    measureHeight();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(1, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("placeHolderClass" in $$props2)
      $$invalidate(4, placeHolderClass = $$props2.placeHolderClass);
    if ("wrapperClass" in $$props2)
      $$invalidate(5, wrapperClass = $$props2.wrapperClass);
    if ("force" in $$props2)
      $$invalidate(6, force = $$props2.force);
    if ("$$scope" in $$props2)
      $$invalidate(10, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*observer, _el, el*/
    386) {
      $: {
        if (observer) {
          if (_el != el) {
            if (_el) {
              observer.unobserve(_el);
              _el.removeEventListener("toggled", handleToggled);
            }
            $$invalidate(8, _el = el);
            observer.observe(el);
            _el.addEventListener("toggled", handleToggled);
          }
        }
      }
    }
    if ($$self.$$.dirty & /*force*/
    64) {
      $: {
        if (force) {
          stopObserving();
        } else {
          startObserving();
        }
      }
    }
    if ($$self.$$.dirty & /*isVisible, ch*/
    513) {
      $:
        $$invalidate(3, stylePlaceHolder = !isVisible && ch ? `height:${ch}px;` : ``);
    }
    if ($$self.$$.dirty & /*wrapperClass, isVisible, placeHolderClass*/
    49) {
      $:
        $$invalidate(2, cssClass = wrapperClass + (isVisible ? "" : " " + placeHolderClass));
    }
  };
  return [
    isVisible,
    el,
    cssClass,
    stylePlaceHolder,
    placeHolderClass,
    wrapperClass,
    force,
    observer,
    _el,
    ch,
    $$scope,
    slots,
    div_binding
  ];
}
var OnDemandRender = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, {
      placeHolderClass: 4,
      wrapperClass: 5,
      force: 6
    });
  }
};
var OnDemandRender_default = OnDemandRender;

// V2TreeFolderComponent.svelte
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i][0];
  child_ctx[0] = list[i][1];
  child_ctx[1] = list[i][2];
  child_ctx[40] = list[i][3];
  return child_ctx;
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[36] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[39] = list[i][0];
  child_ctx[0] = list[i][1];
  child_ctx[1] = list[i][2];
  child_ctx[40] = list[i][3];
  return child_ctx;
}
function create_else_block2(ctx) {
  let ondemandrender;
  let current;
  ondemandrender = new OnDemandRender_default({
    props: {
      wrapperClass: `tree-item nav-folder ${/*collapsed*/
      ctx[18] ? "is-collapsed" : ""}`,
      placeHolderClass: "tf-folder-ph",
      force: !/*collapsed*/
      ctx[18],
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(ondemandrender.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ondemandrender, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ondemandrender_changes = {};
      if (dirty[0] & /*collapsed*/
      262144)
        ondemandrender_changes.wrapperClass = `tree-item nav-folder ${/*collapsed*/
        ctx2[18] ? "is-collapsed" : ""}`;
      if (dirty[0] & /*collapsed*/
      262144)
        ondemandrender_changes.force = !/*collapsed*/
        ctx2[18];
      if (dirty[0] & /*leftOverItems, openFile, trail, suppressLevels, showMenu, hoverPreview, children, folderIcon, isMainTree, openScrollView, isInDedicatedTag, depth, collapsed, isActive, tagName, items, tagsDispHtml*/
      524269 | dirty[1] & /*$$scope*/
      65536) {
        ondemandrender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      ondemandrender.$set(ondemandrender_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ondemandrender.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ondemandrender.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ondemandrender, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let t;
  let each_1_anchor;
  let current;
  let if_block = (
    /*isRoot*/
    ctx[4] && create_if_block_1(ctx)
  );
  let each_value = (
    /*leftOverItems*/
    ctx[15]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*isRoot*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*isRoot*/
          16) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_1(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (dirty[0] & /*leftOverItems, openFile, trail, suppressLevels, showMenu, hoverPreview*/
      42760) {
        each_value = /*leftOverItems*/
        ctx2[15];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (if_block)
        if_block.d(detaching);
      if (detaching)
        detach(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_if_block_2(ctx) {
  let t;
  let each1_anchor;
  let current;
  let each_value_3 = (
    /*children*/
    ctx[14]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks_1[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value_2 = (
    /*leftOverItems*/
    ctx[15]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(target, anchor);
        }
      }
      insert(target, t, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*children, trail, suppressLevels, folderIcon, openFile, showMenu, isMainTree, openScrollView, hoverPreview, isInDedicatedTag, depth*/
      32744) {
        each_value_3 = /*children*/
        ctx2[14];
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_3(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(t.parentNode, t);
          }
        }
        group_outros();
        for (i = each_value_3.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*leftOverItems, openFile, trail, suppressLevels, showMenu, hoverPreview*/
      42760) {
        each_value_2 = /*leftOverItems*/
        ctx2[15];
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each1_anchor.parentNode, each1_anchor);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_3.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks_1, detaching);
      if (detaching)
        detach(t);
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each1_anchor);
    }
  };
}
function create_each_block_3(ctx) {
  let v2treefoldercomponent;
  let current;
  v2treefoldercomponent = new V2TreeFolderComponent({
    props: {
      items: (
        /*subitems*/
        ctx[40]
      ),
      thisName: (
        /*f*/
        ctx[39]
      ),
      trail: [
        .../*trail*/
        ctx[3],
        .../*suppressLevels*/
        ctx[13],
        /*f*/
        ctx[39]
      ],
      folderIcon: (
        /*folderIcon*/
        ctx[7]
      ),
      openFile: (
        /*openFile*/
        ctx[9]
      ),
      isRoot: false,
      showMenu: (
        /*showMenu*/
        ctx[8]
      ),
      isMainTree: (
        /*isMainTree*/
        ctx[5]
      ),
      openScrollView: (
        /*openScrollView*/
        ctx[11]
      ),
      hoverPreview: (
        /*hoverPreview*/
        ctx[10]
      ),
      tagName: (
        /*tagName*/
        ctx[0]
      ),
      tagNameDisp: (
        /*tagNameDisp*/
        ctx[1]
      ),
      depth: (
        /*isInDedicatedTag*/
        ctx[12] ? (
          /*depth*/
          ctx[6]
        ) : (
          /*depth*/
          ctx[6] + 1
        )
      )
    }
  });
  return {
    c() {
      create_component(v2treefoldercomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(v2treefoldercomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const v2treefoldercomponent_changes = {};
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.items = /*subitems*/
        ctx2[40];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.thisName = /*f*/
        ctx2[39];
      if (dirty[0] & /*trail, suppressLevels, children*/
      24584)
        v2treefoldercomponent_changes.trail = [
          .../*trail*/
          ctx2[3],
          .../*suppressLevels*/
          ctx2[13],
          /*f*/
          ctx2[39]
        ];
      if (dirty[0] & /*folderIcon*/
      128)
        v2treefoldercomponent_changes.folderIcon = /*folderIcon*/
        ctx2[7];
      if (dirty[0] & /*openFile*/
      512)
        v2treefoldercomponent_changes.openFile = /*openFile*/
        ctx2[9];
      if (dirty[0] & /*showMenu*/
      256)
        v2treefoldercomponent_changes.showMenu = /*showMenu*/
        ctx2[8];
      if (dirty[0] & /*isMainTree*/
      32)
        v2treefoldercomponent_changes.isMainTree = /*isMainTree*/
        ctx2[5];
      if (dirty[0] & /*openScrollView*/
      2048)
        v2treefoldercomponent_changes.openScrollView = /*openScrollView*/
        ctx2[11];
      if (dirty[0] & /*hoverPreview*/
      1024)
        v2treefoldercomponent_changes.hoverPreview = /*hoverPreview*/
        ctx2[10];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.tagName = /*tagName*/
        ctx2[0];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.tagNameDisp = /*tagNameDisp*/
        ctx2[1];
      if (dirty[0] & /*isInDedicatedTag, depth*/
      4160)
        v2treefoldercomponent_changes.depth = /*isInDedicatedTag*/
        ctx2[12] ? (
          /*depth*/
          ctx2[6]
        ) : (
          /*depth*/
          ctx2[6] + 1
        );
      v2treefoldercomponent.$set(v2treefoldercomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(v2treefoldercomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(v2treefoldercomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(v2treefoldercomponent, detaching);
    }
  };
}
function create_default_slot_2(ctx) {
  let treeitemitemcomponent;
  let t;
  let current;
  treeitemitemcomponent = new V2TreeItemComponent_default({
    props: {
      item: (
        /*item*/
        ctx[36]
      ),
      openFile: (
        /*openFile*/
        ctx[9]
      ),
      trail: [.../*trail*/
      ctx[3], .../*suppressLevels*/
      ctx[13]],
      showMenu: (
        /*showMenu*/
        ctx[8]
      ),
      hoverPreview: (
        /*hoverPreview*/
        ctx[10]
      )
    }
  });
  return {
    c() {
      create_component(treeitemitemcomponent.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(treeitemitemcomponent, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemitemcomponent_changes = {};
      if (dirty[0] & /*leftOverItems*/
      32768)
        treeitemitemcomponent_changes.item = /*item*/
        ctx2[36];
      if (dirty[0] & /*openFile*/
      512)
        treeitemitemcomponent_changes.openFile = /*openFile*/
        ctx2[9];
      if (dirty[0] & /*trail, suppressLevels*/
      8200)
        treeitemitemcomponent_changes.trail = [.../*trail*/
        ctx2[3], .../*suppressLevels*/
        ctx2[13]];
      if (dirty[0] & /*showMenu*/
      256)
        treeitemitemcomponent_changes.showMenu = /*showMenu*/
        ctx2[8];
      if (dirty[0] & /*hoverPreview*/
      1024)
        treeitemitemcomponent_changes.hoverPreview = /*hoverPreview*/
        ctx2[10];
      treeitemitemcomponent.$set(treeitemitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemitemcomponent, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block_2(ctx) {
  let ondemandrender;
  let current;
  ondemandrender = new OnDemandRender_default({
    props: {
      wrapperClass: "tree-item nav-file",
      placeHolderClass: "tf-folder-ph",
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(ondemandrender.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ondemandrender, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ondemandrender_changes = {};
      if (dirty[0] & /*leftOverItems, openFile, trail, suppressLevels, showMenu, hoverPreview*/
      42760 | dirty[1] & /*$$scope*/
      65536) {
        ondemandrender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      ondemandrender.$set(ondemandrender_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ondemandrender.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ondemandrender.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ondemandrender, detaching);
    }
  };
}
function create_default_slot_1(ctx) {
  var _a, _b;
  let div4;
  let div0;
  let t0;
  let div3;
  let div1;
  let t1;
  let div2;
  let span;
  let t2_value = (
    /*items*/
    ((_b = (_a = ctx[2]) == null ? void 0 : _a.length) != null ? _b : 0) + ""
  );
  let t2;
  let t3;
  let div5;
  let current;
  let mounted;
  let dispose;
  let if_block = !/*collapsed*/
  ctx[18] && create_if_block_2(ctx);
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      span = element("span");
      t2 = text(t2_value);
      t3 = space();
      div5 = element("div");
      if (if_block)
        if_block.c();
      attr(div0, "class", "tree-item-icon collapse-icon nav-folder-collapse-indicator");
      toggle_class(
        div0,
        "is-collapsed",
        /*collapsed*/
        ctx[18]
      );
      attr(div1, "class", "tagfolder-titletagname");
      attr(span, "class", "itemscount");
      attr(div2, "class", "tagfolder-quantity itemscount");
      attr(div3, "class", "tree-item-inner nav-folder-title-content lsl-f");
      attr(div4, "class", "tree-item-self is-clickable mod-collapsible nav-folder-title tag-folder-title");
      toggle_class(
        div4,
        "is-active",
        /*isActive*/
        ctx[17]
      );
      attr(div5, "class", "tree-item-children nav-folder-children");
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      div0.innerHTML = /*folderIcon*/
      ctx[7];
      append(div4, t0);
      append(div4, div3);
      append(div3, div1);
      div1.innerHTML = /*tagsDispHtml*/
      ctx[16];
      append(div3, t1);
      append(div3, div2);
      append(div2, span);
      append(span, t2);
      insert(target, t3, anchor);
      insert(target, div5, anchor);
      if (if_block)
        if_block.m(div5, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div0,
            "click",
            /*toggleFolder*/
            ctx[20]
          ),
          listen(
            div2,
            "click",
            /*click_handler*/
            ctx[33]
          ),
          listen(
            div4,
            "click",
            /*toggleFolder*/
            ctx[20]
          ),
          listen(
            div4,
            "contextmenu",
            /*contextmenu_handler*/
            ctx[34]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      var _a2, _b2;
      if (!current || dirty[0] & /*folderIcon*/
      128)
        div0.innerHTML = /*folderIcon*/
        ctx2[7];
      ;
      if (!current || dirty[0] & /*collapsed*/
      262144) {
        toggle_class(
          div0,
          "is-collapsed",
          /*collapsed*/
          ctx2[18]
        );
      }
      if (!current || dirty[0] & /*tagsDispHtml*/
      65536)
        div1.innerHTML = /*tagsDispHtml*/
        ctx2[16];
      ;
      if ((!current || dirty[0] & /*items*/
      4) && t2_value !== (t2_value = /*items*/
      ((_b2 = (_a2 = ctx2[2]) == null ? void 0 : _a2.length) != null ? _b2 : 0) + ""))
        set_data(t2, t2_value);
      if (!current || dirty[0] & /*isActive*/
      131072) {
        toggle_class(
          div4,
          "is-active",
          /*isActive*/
          ctx2[17]
        );
      }
      if (!/*collapsed*/
      ctx2[18]) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*collapsed*/
          262144) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div5, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div4);
      if (detaching)
        detach(t3);
      if (detaching)
        detach(div5);
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = (
    /*children*/
    ctx[14]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*children, folderIcon, openFile, showMenu, isMainTree, openScrollView, hoverPreview, depth*/
      20448) {
        each_value_1 = /*children*/
        ctx2[14];
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      destroy_each(each_blocks, detaching);
      if (detaching)
        detach(each_1_anchor);
    }
  };
}
function create_each_block_1(ctx) {
  let v2treefoldercomponent;
  let current;
  v2treefoldercomponent = new V2TreeFolderComponent({
    props: {
      items: (
        /*subitems*/
        ctx[40]
      ),
      thisName: (
        /*f*/
        ctx[39]
      ),
      trail: [
        /*f*/
        ctx[39]
      ],
      folderIcon: (
        /*folderIcon*/
        ctx[7]
      ),
      openFile: (
        /*openFile*/
        ctx[9]
      ),
      showMenu: (
        /*showMenu*/
        ctx[8]
      ),
      isRoot: false,
      isMainTree: (
        /*isMainTree*/
        ctx[5]
      ),
      openScrollView: (
        /*openScrollView*/
        ctx[11]
      ),
      hoverPreview: (
        /*hoverPreview*/
        ctx[10]
      ),
      tagName: (
        /*tagName*/
        ctx[0]
      ),
      tagNameDisp: (
        /*tagNameDisp*/
        ctx[1]
      ),
      depth: (
        /*depth*/
        ctx[6] + 1
      )
    }
  });
  return {
    c() {
      create_component(v2treefoldercomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(v2treefoldercomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const v2treefoldercomponent_changes = {};
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.items = /*subitems*/
        ctx2[40];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.thisName = /*f*/
        ctx2[39];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.trail = [
          /*f*/
          ctx2[39]
        ];
      if (dirty[0] & /*folderIcon*/
      128)
        v2treefoldercomponent_changes.folderIcon = /*folderIcon*/
        ctx2[7];
      if (dirty[0] & /*openFile*/
      512)
        v2treefoldercomponent_changes.openFile = /*openFile*/
        ctx2[9];
      if (dirty[0] & /*showMenu*/
      256)
        v2treefoldercomponent_changes.showMenu = /*showMenu*/
        ctx2[8];
      if (dirty[0] & /*isMainTree*/
      32)
        v2treefoldercomponent_changes.isMainTree = /*isMainTree*/
        ctx2[5];
      if (dirty[0] & /*openScrollView*/
      2048)
        v2treefoldercomponent_changes.openScrollView = /*openScrollView*/
        ctx2[11];
      if (dirty[0] & /*hoverPreview*/
      1024)
        v2treefoldercomponent_changes.hoverPreview = /*hoverPreview*/
        ctx2[10];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.tagName = /*tagName*/
        ctx2[0];
      if (dirty[0] & /*children*/
      16384)
        v2treefoldercomponent_changes.tagNameDisp = /*tagNameDisp*/
        ctx2[1];
      if (dirty[0] & /*depth*/
      64)
        v2treefoldercomponent_changes.depth = /*depth*/
        ctx2[6] + 1;
      v2treefoldercomponent.$set(v2treefoldercomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(v2treefoldercomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(v2treefoldercomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(v2treefoldercomponent, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let treeitemitemcomponent;
  let t;
  let current;
  treeitemitemcomponent = new V2TreeItemComponent_default({
    props: {
      item: (
        /*item*/
        ctx[36]
      ),
      openFile: (
        /*openFile*/
        ctx[9]
      ),
      trail: [.../*trail*/
      ctx[3], .../*suppressLevels*/
      ctx[13]],
      showMenu: (
        /*showMenu*/
        ctx[8]
      ),
      hoverPreview: (
        /*hoverPreview*/
        ctx[10]
      )
    }
  });
  return {
    c() {
      create_component(treeitemitemcomponent.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(treeitemitemcomponent, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const treeitemitemcomponent_changes = {};
      if (dirty[0] & /*leftOverItems*/
      32768)
        treeitemitemcomponent_changes.item = /*item*/
        ctx2[36];
      if (dirty[0] & /*openFile*/
      512)
        treeitemitemcomponent_changes.openFile = /*openFile*/
        ctx2[9];
      if (dirty[0] & /*trail, suppressLevels*/
      8200)
        treeitemitemcomponent_changes.trail = [.../*trail*/
        ctx2[3], .../*suppressLevels*/
        ctx2[13]];
      if (dirty[0] & /*showMenu*/
      256)
        treeitemitemcomponent_changes.showMenu = /*showMenu*/
        ctx2[8];
      if (dirty[0] & /*hoverPreview*/
      1024)
        treeitemitemcomponent_changes.hoverPreview = /*hoverPreview*/
        ctx2[10];
      treeitemitemcomponent.$set(treeitemitemcomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(treeitemitemcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(treeitemitemcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(treeitemitemcomponent, detaching);
      if (detaching)
        detach(t);
    }
  };
}
function create_each_block2(ctx) {
  let ondemandrender;
  let current;
  ondemandrender = new OnDemandRender_default({
    props: {
      wrapperClass: "tree-item nav-file",
      placeHolderClass: "tf-file-ph",
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(ondemandrender.$$.fragment);
    },
    m(target, anchor) {
      mount_component(ondemandrender, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const ondemandrender_changes = {};
      if (dirty[0] & /*leftOverItems, openFile, trail, suppressLevels, showMenu, hoverPreview*/
      42760 | dirty[1] & /*$$scope*/
      65536) {
        ondemandrender_changes.$$scope = { dirty, ctx: ctx2 };
      }
      ondemandrender.$set(ondemandrender_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(ondemandrender.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(ondemandrender.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(ondemandrender, detaching);
    }
  };
}
function create_fragment5(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block2, create_else_block2];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*isRoot*/
      ctx2[4] || !/*isMainTree*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if_blocks[current_block_type_index].d(detaching);
      if (detaching)
        detach(if_block_anchor);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let trailKey;
  let collapsed;
  let sortFunc;
  let trailLower;
  let isActive;
  let tagsDispHtml;
  let $tagFolderSetting;
  let $v2expandedTags;
  component_subscribe($$self, tagFolderSetting, ($$value) => $$invalidate(35, $tagFolderSetting = $$value));
  component_subscribe($$self, v2expandedTags, ($$value) => $$invalidate(32, $v2expandedTags = $$value));
  let { thisName = "" } = $$props;
  let { items = [] } = $$props;
  let { tagName = "" } = $$props;
  let { tagNameDisp = [] } = $$props;
  let { trail = [] } = $$props;
  let { isRoot } = $$props;
  let { isMainTree } = $$props;
  let { depth = 1 } = $$props;
  let { folderIcon = "" } = $$props;
  let { showMenu } = $$props;
  let { openFile } = $$props;
  let { hoverPreview } = $$props;
  let { openScrollView } = $$props;
  v2expandedTags.subscribe((expTags) => {
    if (trailKey == void 0)
      return;
    const collapsedNew = !expTags.has(trailKey);
    if (collapsed != collapsedNew) {
      $$invalidate(18, collapsed = collapsedNew);
    }
  });
  let _setting = $tagFolderSetting;
  tagFolderSetting.subscribe((setting) => {
    $$invalidate(22, _setting = setting);
  });
  let _tagInfo = {};
  tagInfo.subscribe((info) => {
    $$invalidate(23, _tagInfo = info);
  });
  let _currentActiveFilePath = "";
  currentFile.subscribe((path) => {
    $$invalidate(24, _currentActiveFilePath = path);
  });
  function handleOpenScroll(e, trails, filePaths) {
    openScrollView(null, "", joinPartialPath(removeIntermediatePath(trails)).join(", "), filePaths);
    e.preventDefault();
  }
  function toggleFolder(evt) {
    evt.preventDefault();
    evt.stopPropagation();
    if (_setting.useMultiPaneList) {
      selectedTags.set(trail);
    }
    v2expandedTags.update((evt2) => {
      if (evt2.has(trailKey)) {
        evt2.delete(trailKey);
      } else {
        evt2.add(trailKey);
      }
      return evt2;
    });
  }
  let tags = [];
  let isInDedicatedTag = false;
  let previousTrail = "";
  let isSuppressibleLevel = false;
  let suppressLevels = [];
  let children2 = [];
  let leftOverItems = [];
  let tagsDisp = [];
  const click_handler = (e) => handleOpenScroll(e, trail, items.map((e2) => e2.path));
  const contextmenu_handler = (evt) => {
    showMenu(evt, [...trail, ...suppressLevels], tagName, items);
  };
  $$self.$$set = ($$props2) => {
    if ("thisName" in $$props2)
      $$invalidate(21, thisName = $$props2.thisName);
    if ("items" in $$props2)
      $$invalidate(2, items = $$props2.items);
    if ("tagName" in $$props2)
      $$invalidate(0, tagName = $$props2.tagName);
    if ("tagNameDisp" in $$props2)
      $$invalidate(1, tagNameDisp = $$props2.tagNameDisp);
    if ("trail" in $$props2)
      $$invalidate(3, trail = $$props2.trail);
    if ("isRoot" in $$props2)
      $$invalidate(4, isRoot = $$props2.isRoot);
    if ("isMainTree" in $$props2)
      $$invalidate(5, isMainTree = $$props2.isMainTree);
    if ("depth" in $$props2)
      $$invalidate(6, depth = $$props2.depth);
    if ("folderIcon" in $$props2)
      $$invalidate(7, folderIcon = $$props2.folderIcon);
    if ("showMenu" in $$props2)
      $$invalidate(8, showMenu = $$props2.showMenu);
    if ("openFile" in $$props2)
      $$invalidate(9, openFile = $$props2.openFile);
    if ("hoverPreview" in $$props2)
      $$invalidate(10, hoverPreview = $$props2.hoverPreview);
    if ("openScrollView" in $$props2)
      $$invalidate(11, openScrollView = $$props2.openScrollView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*trail*/
    8) {
      $:
        $$invalidate(31, trailKey = trail.join("*"));
    }
    if ($$self.$$.dirty[0] & /*isRoot*/
    16 | $$self.$$.dirty[1] & /*$v2expandedTags, trailKey*/
    3) {
      $:
        $$invalidate(18, collapsed = !isRoot && !$v2expandedTags.has(trailKey));
    }
    if ($$self.$$.dirty[0] & /*_setting, _tagInfo*/
    12582912) {
      $:
        $$invalidate(29, sortFunc = selectCompareMethodTags(_setting, _tagInfo));
    }
    if ($$self.$$.dirty[0] & /*trail*/
    8) {
      $:
        $$invalidate(30, trailLower = trail.map((e) => e.toLocaleLowerCase()));
    }
    if ($$self.$$.dirty[0] & /*items, trail, isMainTree, _setting, depth, previousTrail, isInDedicatedTag, isSuppressibleLevel, thisName, trailLower*/
    1281364076) {
      $: {
        $$invalidate(12, isInDedicatedTag = false);
        if (items) {
          $$invalidate(25, tags = []);
          $$invalidate(26, previousTrail = "");
          if (trail.length >= 1 && trail[trail.length - 1].endsWith("/")) {
            $$invalidate(26, previousTrail = trail[trail.length - 1]);
            $$invalidate(12, isInDedicatedTag = true);
          }
          if (isMainTree && (!(_setting === null || _setting === void 0 ? void 0 : _setting.expandLimit) || (_setting === null || _setting === void 0 ? void 0 : _setting.expandLimit) && depth < _setting.expandLimit)) {
            $$invalidate(27, isSuppressibleLevel = false);
            const tagsAll = uniqueCaseIntensive(items.flatMap((e) => [...e.tags]));
            const lastTrailTagLC = trimTrailingSlash(previousTrail).toLocaleLowerCase();
            if (isInDedicatedTag && tagsAll.some((e) => e.toLocaleLowerCase() == lastTrailTagLC)) {
              $$invalidate(12, isInDedicatedTag = false);
            }
            let existTags = [...tagsAll];
            existTags = existTags.filter((tag) => trail.every((trail2) => trimTrailingSlash(tag.toLocaleLowerCase()) !== trimTrailingSlash(trail2.toLocaleLowerCase())));
            if (isInDedicatedTag) {
              existTags = existTags.filter((e) => (e + "/").startsWith(previousTrail));
              existTags = existTags.map((e) => (e + "/").startsWith(previousTrail) ? e.substring(previousTrail.length) : e);
            }
            let existTagsFiltered1 = [];
            if (!_setting.doNotSimplifyTags) {
              if (items.length == 1) {
                existTagsFiltered1 = existTags;
                $$invalidate(27, isSuppressibleLevel = true);
              } else {
                const allChildTags = uniqueCaseIntensive(items.map((e) => e.tags.sort().join("**")));
                if (allChildTags.length == 1) {
                  $$invalidate(27, isSuppressibleLevel = true);
                  existTagsFiltered1 = existTags;
                }
              }
            }
            if (!isSuppressibleLevel) {
              const removeItems = [thisName.toLocaleLowerCase()];
              if (_setting.reduceNestedParent) {
                removeItems.push(...trailLower);
              }
              const tagsOnNextLevel = uniqueCaseIntensive(existTags.map((e) => {
                const idx = e.indexOf("/");
                if (idx < 1)
                  return e;
                let piece = e.substring(0, idx + 1);
                let idx2 = idx;
                while (removeItems.contains(piece.toLocaleLowerCase())) {
                  idx2 = e.indexOf("/", idx2 + 1);
                  if (idx2 === -1) {
                    piece = e;
                    break;
                  }
                  piece = e.substring(0, idx2 + 1);
                }
                return piece;
              }));
              existTagsFiltered1 = tagsOnNextLevel;
            }
            if (isInDedicatedTag) {
              existTagsFiltered1 = existTagsFiltered1.map((e) => previousTrail + e);
            }
            const existTagsFiltered1LC = existTagsFiltered1.map((e) => e.toLocaleLowerCase());
            const existTagsFiltered2 = existTagsFiltered1.map((e) => existTagsFiltered1LC.contains(e.toLocaleLowerCase() + "/") ? e + "/" : e);
            const existTagsFiltered3 = uniqueCaseIntensive(existTagsFiltered2);
            $$invalidate(25, tags = uniqueCaseIntensive(removeIntermediatePath(existTagsFiltered3)));
          }
        }
      }
    }
    if ($$self.$$.dirty[0] & /*_setting, depth, tags, trailLower, isMainTree, isSuppressibleLevel, _tagInfo, items, sortFunc, isRoot*/
    1790967924) {
      $: {
        $$invalidate(13, suppressLevels = []);
        if ((_setting === null || _setting === void 0 ? void 0 : _setting.expandLimit) && depth >= _setting.expandLimit) {
          $$invalidate(14, children2 = []);
          $$invalidate(13, suppressLevels = getExtraTags(tags, trailLower, _setting.reduceNestedParent));
        } else if (!isMainTree) {
          $$invalidate(14, children2 = []);
        } else if (isSuppressibleLevel) {
          $$invalidate(14, children2 = []);
          $$invalidate(13, suppressLevels = getExtraTags(tags, trailLower, _setting.reduceNestedParent));
        } else {
          let wChildren = tags.map((tag) => [
            tag,
            ...parseTagName(tag, _tagInfo),
            items.filter((item) => item.tags.some((itemTag) => pathMatch(itemTag, tag)))
          ]).filter((child) => child[3].length != 0);
          wChildren = wChildren.sort(sortFunc);
          if (_setting.mergeRedundantCombination) {
            let out = [];
            const isShown = /* @__PURE__ */ new Set();
            for (const [tag, tagName2, tagsDisp2, items2] of wChildren) {
              const list = [];
              for (const v of items2) {
                if (!isShown.has(v.path)) {
                  list.push(v);
                  isShown.add(v.path);
                }
              }
              if (list.length != 0)
                out.push([tag, tagName2, tagsDisp2, list]);
            }
            wChildren = out;
          }
          if (isMainTree && isRoot) {
            const archiveTags = _setting.archiveTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
            wChildren = wChildren.map((e) => archiveTags.some((aTag) => `${aTag}//`.startsWith(e[V2FI_IDX_TAG].toLocaleLowerCase() + "/")) ? e : [
              e[V2FI_IDX_TAG],
              e[V2FI_IDX_TAGNAME],
              e[V2FI_IDX_TAGDISP],
              e[V2FI_IDX_CHILDREN].filter((items2) => !items2.tags.some((e2) => archiveTags.contains(e2.toLocaleLowerCase())))
            ]).filter((child) => child[V2FI_IDX_CHILDREN].length != 0);
          }
          $$invalidate(14, children2 = wChildren);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*items, _currentActiveFilePath*/
    16777220) {
      $:
        $$invalidate(17, isActive = items && items.some((e) => e.path == _currentActiveFilePath));
    }
    if ($$self.$$.dirty[0] & /*tagName, tagNameDisp, thisName, _tagInfo*/
    10485763) {
      $: {
        if (tagName == "" && tagNameDisp.length == 0) {
          const [wTagName, wTagNameDisp] = parseTagName(thisName, _tagInfo);
          $$invalidate(0, tagName = wTagName);
          $$invalidate(1, tagNameDisp = wTagNameDisp);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*isSuppressibleLevel, isInDedicatedTag, tagNameDisp, suppressLevels*/
    134230018) {
      $: {
        if (isSuppressibleLevel && isInDedicatedTag) {
          $$invalidate(28, tagsDisp = [
            [
              ...tagNameDisp,
              ...suppressLevels.flatMap((e) => e.split("/").map((e2) => renderSpecialTag(e2)))
            ]
          ]);
        } else if (isSuppressibleLevel) {
          $$invalidate(28, tagsDisp = [
            tagNameDisp,
            ...suppressLevels.map((e) => e.split("/").map((e2) => renderSpecialTag(e2)))
          ]);
        } else {
          $$invalidate(28, tagsDisp = [tagNameDisp]);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*tagsDisp*/
    268435456) {
      $:
        $$invalidate(16, tagsDispHtml = tagsDisp.map((e) => `<span class="tagfolder-tag tag-tag">${e.map((ee) => `<span class="tagfolder-tag tag-nested-tag">${escapeStringToHTML(ee)}</span>`).join("")}</span>`).join(""));
    }
    if ($$self.$$.dirty[0] & /*_setting, isMainTree, isRoot, items, isInDedicatedTag, children*/
    4214836) {
      $: {
        if (_setting.useMultiPaneList && isMainTree) {
          $$invalidate(15, leftOverItems = []);
        } else {
          if (isRoot && isMainTree) {
            if (_setting.expandUntaggedToRoot) {
              $$invalidate(15, leftOverItems = items.filter((e) => e.tags.contains("_untagged")));
            } else {
              $$invalidate(15, leftOverItems = []);
            }
          } else if (isRoot && !isMainTree) {
            $$invalidate(15, leftOverItems = items);
          } else {
            if (_setting.hideItems == "NONE") {
              $$invalidate(15, leftOverItems = items);
            } else if (_setting.hideItems == "DEDICATED_INTERMIDIATES" && isInDedicatedTag || _setting.hideItems == "ALL_EXCEPT_BOTTOM") {
              $$invalidate(15, leftOverItems = items.filter((e) => !children2.map((e2) => e2[V2FI_IDX_CHILDREN]).flat().find((ee) => e.path == ee.path)));
            } else {
              $$invalidate(15, leftOverItems = items);
            }
          }
        }
      }
    }
  };
  return [
    tagName,
    tagNameDisp,
    items,
    trail,
    isRoot,
    isMainTree,
    depth,
    folderIcon,
    showMenu,
    openFile,
    hoverPreview,
    openScrollView,
    isInDedicatedTag,
    suppressLevels,
    children2,
    leftOverItems,
    tagsDispHtml,
    isActive,
    collapsed,
    handleOpenScroll,
    toggleFolder,
    thisName,
    _setting,
    _tagInfo,
    _currentActiveFilePath,
    tags,
    previousTrail,
    isSuppressibleLevel,
    tagsDisp,
    sortFunc,
    trailLower,
    trailKey,
    $v2expandedTags,
    click_handler,
    contextmenu_handler
  ];
}
var V2TreeFolderComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        thisName: 21,
        items: 2,
        tagName: 0,
        tagNameDisp: 1,
        trail: 3,
        isRoot: 4,
        isMainTree: 5,
        depth: 6,
        folderIcon: 7,
        showMenu: 8,
        openFile: 9,
        hoverPreview: 10,
        openScrollView: 11
      },
      null,
      [-1, -1]
    );
  }
};
var V2TreeFolderComponent_default = V2TreeFolderComponent;

// TagFolderViewComponent.svelte
var import_obsidian3 = require("obsidian");
function add_css3(target) {
  append_styles(target, "svelte-1xm87ro", ".nav-files-container.svelte-1xm87ro{height:100%}");
}
function create_if_block_22(ctx) {
  let div0;
  let t0;
  let div1;
  let t1;
  let div2;
  let div2_class_value;
  let mounted;
  let dispose;
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div1 = element("div");
      t1 = space();
      div2 = element("div");
      attr(div0, "class", "clickable-icon nav-action-button");
      attr(div0, "aria-label", "Change sort order");
      attr(div1, "class", "clickable-icon nav-action-button");
      attr(div1, "aria-label", "Expand limit");
      attr(div2, "class", div2_class_value = null_to_empty("clickable-icon nav-action-button" + /*showSearch*/
      (ctx[10] ? " is-active" : "")) + " svelte-1xm87ro");
      attr(div2, "aria-label", "Search");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      div0.innerHTML = /*upAndDownArrowsIcon*/
      ctx[14];
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      div1.innerHTML = /*stackedLevels*/
      ctx[15];
      insert(target, t1, anchor);
      insert(target, div2, anchor);
      div2.innerHTML = /*searchIcon*/
      ctx[16];
      if (!mounted) {
        dispose = [
          listen(div0, "click", function() {
            if (is_function(
              /*showOrder*/
              ctx[4]
            ))
              ctx[4].apply(this, arguments);
          }),
          listen(div1, "click", function() {
            if (is_function(
              /*showLevelSelect*/
              ctx[3]
            ))
              ctx[3].apply(this, arguments);
          }),
          listen(
            div2,
            "click",
            /*toggleSearch*/
            ctx[21]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*upAndDownArrowsIcon*/
      16384)
        div0.innerHTML = /*upAndDownArrowsIcon*/
        ctx[14];
      ;
      if (dirty[0] & /*stackedLevels*/
      32768)
        div1.innerHTML = /*stackedLevels*/
        ctx[15];
      ;
      if (dirty[0] & /*searchIcon*/
      65536)
        div2.innerHTML = /*searchIcon*/
        ctx[16];
      ;
      if (dirty[0] & /*showSearch*/
      1024 && div2_class_value !== (div2_class_value = null_to_empty("clickable-icon nav-action-button" + /*showSearch*/
      (ctx[10] ? " is-active" : "")) + " svelte-1xm87ro")) {
        attr(div2, "class", div2_class_value);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      if (detaching)
        detach(t1);
      if (detaching)
        detach(div2);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_12(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "class", "clickable-icon nav-action-button");
      attr(div, "aria-label", "Switch List/Tree");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      div.innerHTML = /*switchIcon*/
      ctx[17];
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*doSwitch*/
          ctx[23]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*switchIcon*/
      131072)
        div.innerHTML = /*switchIcon*/
        ctx2[17];
      ;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block3(ctx) {
  let div1;
  let input;
  let t;
  let div0;
  let mounted;
  let dispose;
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t = space();
      div0 = element("div");
      attr(input, "type", "search");
      attr(input, "spellcheck", "false");
      attr(input, "placeholder", "Type to start search...");
      attr(div0, "class", "search-input-clear-button");
      attr(div0, "aria-label", "Clear search");
      set_style(
        div0,
        "display",
        /*search*/
        ctx[9].trim() == "" ? "none" : ""
      );
      attr(div1, "class", "search-input-container");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, input);
      set_input_value(
        input,
        /*search*/
        ctx[9]
      );
      append(div1, t);
      append(div1, div0);
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[32]
          ),
          listen(
            div0,
            "click",
            /*clearSearch*/
            ctx[22]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*search*/
      512 && input.value !== /*search*/
      ctx2[9]) {
        set_input_value(
          input,
          /*search*/
          ctx2[9]
        );
      }
      if (dirty[0] & /*search*/
      512) {
        set_style(
          div0,
          "display",
          /*search*/
          ctx2[9].trim() == "" ? "none" : ""
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment6(ctx) {
  let div0;
  let t0;
  let div3;
  let div2;
  let div1;
  let t1;
  let t2;
  let t3;
  let t4;
  let div8;
  let div7;
  let div5;
  let div4;
  let t5;
  let t6;
  let div6;
  let v2treefoldercomponent;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*isMainTree*/
    ctx[8] && create_if_block_22(ctx)
  );
  let if_block1 = (
    /*isViewSwitchable*/
    ctx[7] && create_if_block_12(ctx)
  );
  let if_block2 = (
    /*showSearch*/
    ctx[10] && /*isMainTree*/
    ctx[8] && create_if_block3(ctx)
  );
  v2treefoldercomponent = new V2TreeFolderComponent_default({
    props: {
      items: (
        /*viewItems*/
        ctx[18]
      ),
      folderIcon: (
        /*folderIcon*/
        ctx[13]
      ),
      thisName: "",
      isRoot: true,
      showMenu: (
        /*showMenu*/
        ctx[2]
      ),
      openFile: (
        /*openFile*/
        ctx[1]
      ),
      isMainTree: (
        /*isMainTree*/
        ctx[8]
      ),
      hoverPreview: (
        /*hoverPreview*/
        ctx[0]
      ),
      openScrollView: (
        /*openScrollView*/
        ctx[6]
      ),
      depth: 1
    }
  });
  return {
    c() {
      div0 = element("div");
      t0 = space();
      div3 = element("div");
      div2 = element("div");
      div1 = element("div");
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      div8 = element("div");
      div7 = element("div");
      div5 = element("div");
      div4 = element("div");
      t5 = text(
        /*headerTitle*/
        ctx[20]
      );
      t6 = space();
      div6 = element("div");
      create_component(v2treefoldercomponent.$$.fragment);
      div0.hidden = true;
      attr(div1, "class", "clickable-icon nav-action-button");
      attr(div1, "aria-label", "New note");
      attr(div2, "class", "nav-buttons-container tagfolder-buttons-container");
      attr(div3, "class", "nav-header");
      attr(div4, "class", "tree-item-inner nav-folder-title-content");
      attr(div5, "class", "tree-item-self nav-folder-title");
      attr(div6, "class", "tree-item-children nav-folder-children");
      attr(div7, "class", "tree-item nav-folder mod-root");
      attr(div8, "class", "nav-files-container node-insert-event svelte-1xm87ro");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      ctx[31](div0);
      insert(target, t0, anchor);
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, div1);
      div1.innerHTML = /*newNoteIcon*/
      ctx[12];
      append(div2, t1);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      insert(target, t3, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t4, anchor);
      insert(target, div8, anchor);
      append(div8, div7);
      append(div7, div5);
      append(div5, div4);
      append(div4, t5);
      append(div7, t6);
      append(div7, div6);
      mount_component(v2treefoldercomponent, div6, null);
      ctx[33](div8);
      current = true;
      if (!mounted) {
        dispose = listen(div1, "click", function() {
          if (is_function(
            /*newNote*/
            ctx[5]
          ))
            ctx[5].apply(this, arguments);
        });
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (!current || dirty[0] & /*newNoteIcon*/
      4096)
        div1.innerHTML = /*newNoteIcon*/
        ctx[12];
      ;
      if (
        /*isMainTree*/
        ctx[8]
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_22(ctx);
          if_block0.c();
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*isViewSwitchable*/
        ctx[7]
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_12(ctx);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*showSearch*/
        ctx[10] && /*isMainTree*/
        ctx[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block3(ctx);
          if_block2.c();
          if_block2.m(t4.parentNode, t4);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty[0] & /*headerTitle*/
      1048576)
        set_data(
          t5,
          /*headerTitle*/
          ctx[20]
        );
      const v2treefoldercomponent_changes = {};
      if (dirty[0] & /*viewItems*/
      262144)
        v2treefoldercomponent_changes.items = /*viewItems*/
        ctx[18];
      if (dirty[0] & /*folderIcon*/
      8192)
        v2treefoldercomponent_changes.folderIcon = /*folderIcon*/
        ctx[13];
      if (dirty[0] & /*showMenu*/
      4)
        v2treefoldercomponent_changes.showMenu = /*showMenu*/
        ctx[2];
      if (dirty[0] & /*openFile*/
      2)
        v2treefoldercomponent_changes.openFile = /*openFile*/
        ctx[1];
      if (dirty[0] & /*isMainTree*/
      256)
        v2treefoldercomponent_changes.isMainTree = /*isMainTree*/
        ctx[8];
      if (dirty[0] & /*hoverPreview*/
      1)
        v2treefoldercomponent_changes.hoverPreview = /*hoverPreview*/
        ctx[0];
      if (dirty[0] & /*openScrollView*/
      64)
        v2treefoldercomponent_changes.openScrollView = /*openScrollView*/
        ctx[6];
      v2treefoldercomponent.$set(v2treefoldercomponent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(v2treefoldercomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(v2treefoldercomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div0);
      ctx[31](null);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div3);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (detaching)
        detach(t3);
      if (if_block2)
        if_block2.d(detaching);
      if (detaching)
        detach(t4);
      if (detaching)
        detach(div8);
      destroy_component(v2treefoldercomponent);
      ctx[33](null);
      mounted = false;
      dispose();
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let headerTitle;
  let $tagFolderSetting;
  component_subscribe($$self, tagFolderSetting, ($$value) => $$invalidate(34, $tagFolderSetting = $$value));
  var _a;
  let { hoverPreview } = $$props;
  let { openFile } = $$props;
  let { vaultName = "" } = $$props;
  let { title = "" } = $$props;
  let { tags = [] } = $$props;
  let { showMenu } = $$props;
  let { showLevelSelect } = $$props;
  let { showOrder } = $$props;
  let { newNote } = $$props;
  let { openScrollView } = $$props;
  let { isViewSwitchable } = $$props;
  let { switchView } = $$props;
  let isMainTree;
  let viewItemsSrc = [];
  allViewItems.subscribe((items) => {
    $$invalidate(29, viewItemsSrc = items);
  });
  let search = "";
  searchString.subscribe((newSearch) => {
    if (search != newSearch) {
      if (newSearch != "") {
        $$invalidate(10, showSearch = true);
      }
      $$invalidate(9, search = newSearch);
    }
  });
  let _setting = $tagFolderSetting;
  tagFolderSetting.subscribe((setting) => {
    $$invalidate(30, _setting = setting);
  });
  let showSearch = false;
  function toggleSearch() {
    $$invalidate(10, showSearch = !showSearch);
    if (!showSearch) {
      $$invalidate(9, search = "");
    }
  }
  function clearSearch() {
    $$invalidate(9, search = "");
  }
  function doSwitch() {
    if (switchView) {
      switchView();
    }
  }
  let iconDivEl;
  let newNoteIcon = "";
  let folderIcon = "";
  let upAndDownArrowsIcon = "";
  let stackedLevels = "";
  let searchIcon = "";
  let switchIcon = "";
  onMount(async () => {
    (0, import_obsidian3.setIcon)(iconDivEl, "right-triangle");
    $$invalidate(13, folderIcon = `${iconDivEl.innerHTML}`);
    (0, import_obsidian3.setIcon)(iconDivEl, "lucide-edit");
    $$invalidate(12, newNoteIcon = `${iconDivEl.innerHTML}`);
    if (isMainTree) {
      (0, import_obsidian3.setIcon)(iconDivEl, "lucide-sort-asc");
      $$invalidate(14, upAndDownArrowsIcon = iconDivEl.innerHTML);
      (0, import_obsidian3.setIcon)(iconDivEl, "stacked-levels");
      $$invalidate(15, stackedLevels = iconDivEl.innerHTML);
      (0, import_obsidian3.setIcon)(iconDivEl, "search");
      $$invalidate(16, searchIcon = iconDivEl.innerHTML);
    }
    (0, import_obsidian3.setIcon)(iconDivEl, "lucide-arrow-left-right");
    $$invalidate(17, switchIcon = iconDivEl.innerHTML);
  });
  let viewItems = [];
  let scrollParent;
  setContext("tf-list", { getScrollParent: () => scrollParent });
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      iconDivEl = $$value;
      $$invalidate(11, iconDivEl);
    });
  }
  function input_input_handler() {
    search = this.value;
    $$invalidate(9, search);
  }
  function div8_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      scrollParent = $$value;
      $$invalidate(19, scrollParent);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("hoverPreview" in $$props2)
      $$invalidate(0, hoverPreview = $$props2.hoverPreview);
    if ("openFile" in $$props2)
      $$invalidate(1, openFile = $$props2.openFile);
    if ("vaultName" in $$props2)
      $$invalidate(24, vaultName = $$props2.vaultName);
    if ("title" in $$props2)
      $$invalidate(25, title = $$props2.title);
    if ("tags" in $$props2)
      $$invalidate(26, tags = $$props2.tags);
    if ("showMenu" in $$props2)
      $$invalidate(2, showMenu = $$props2.showMenu);
    if ("showLevelSelect" in $$props2)
      $$invalidate(3, showLevelSelect = $$props2.showLevelSelect);
    if ("showOrder" in $$props2)
      $$invalidate(4, showOrder = $$props2.showOrder);
    if ("newNote" in $$props2)
      $$invalidate(5, newNote = $$props2.newNote);
    if ("openScrollView" in $$props2)
      $$invalidate(6, openScrollView = $$props2.openScrollView);
    if ("isViewSwitchable" in $$props2)
      $$invalidate(7, isViewSwitchable = $$props2.isViewSwitchable);
    if ("switchView" in $$props2)
      $$invalidate(27, switchView = $$props2.switchView);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*search*/
    512) {
      $: {
        searchString.set(search);
      }
    }
    if ($$self.$$.dirty[0] & /*title, vaultName*/
    50331648) {
      $:
        $$invalidate(20, headerTitle = title == "" ? `Tags: ${vaultName}` : `Items: ${title}`);
    }
    if ($$self.$$.dirty[0] & /*tags*/
    67108864) {
      $:
        $$invalidate(8, isMainTree = tags.length == 0);
    }
    if ($$self.$$.dirty[0] & /*viewItemsSrc, isMainTree, tags, _a, _setting*/
    1946157312) {
      $: {
        if (viewItemsSrc) {
          if (isMainTree) {
            $$invalidate(18, viewItems = viewItemsSrc);
          } else {
            let items = viewItemsSrc;
            const lowerTags = tags.map((e) => e.toLocaleLowerCase());
            for (const tag of lowerTags) {
              items = items.filter((e) => e.tags.some((e2) => (e2.toLocaleLowerCase() + "/").startsWith(tag)));
            }
            const firstLevel = trimTrailingSlash($$invalidate(28, _a = tags.first()) !== null && _a !== void 0 ? _a : "").toLocaleLowerCase();
            const archiveTags = _setting.archiveTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
            if (!archiveTags.contains(firstLevel)) {
              items = items.filter((item) => !item.tags.some((e) => archiveTags.contains(e.toLocaleLowerCase())));
            }
            $$invalidate(18, viewItems = items);
          }
        }
      }
    }
  };
  return [
    hoverPreview,
    openFile,
    showMenu,
    showLevelSelect,
    showOrder,
    newNote,
    openScrollView,
    isViewSwitchable,
    isMainTree,
    search,
    showSearch,
    iconDivEl,
    newNoteIcon,
    folderIcon,
    upAndDownArrowsIcon,
    stackedLevels,
    searchIcon,
    switchIcon,
    viewItems,
    scrollParent,
    headerTitle,
    toggleSearch,
    clearSearch,
    doSwitch,
    vaultName,
    title,
    tags,
    switchView,
    _a,
    viewItemsSrc,
    _setting,
    div0_binding,
    input_input_handler,
    div8_binding
  ];
}
var TagFolderViewComponent = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        hoverPreview: 0,
        openFile: 1,
        vaultName: 24,
        title: 25,
        tags: 26,
        showMenu: 2,
        showLevelSelect: 3,
        showOrder: 4,
        newNote: 5,
        openScrollView: 6,
        isViewSwitchable: 7,
        switchView: 27
      },
      add_css3,
      [-1, -1]
    );
  }
};
var TagFolderViewComponent_default = TagFolderViewComponent;

// TagFolderViewBase.ts
var import_obsidian5 = require("obsidian");

// dialog.ts
var import_obsidian4 = require("obsidian");
var askString = (app2, title, placeholder, initialText) => {
  return new Promise((res) => {
    const popover = new PopoverSelectString(app2, title, placeholder, initialText, (result) => res(result));
    popover.open();
  });
};
var PopoverSelectString = class extends import_obsidian4.SuggestModal {
  constructor(app2, title, placeholder, initialText, callback) {
    super(app2);
    this.callback = () => {
    };
    this.title = "";
    this.app = app2;
    this.title = title;
    this.setPlaceholder(placeholder != null ? placeholder : ">");
    this.callback = callback;
    setTimeout(() => {
      this.inputEl.value = initialText;
    });
    const parent = this.containerEl.querySelector(".prompt");
    if (parent) {
      parent.addClass("override-input");
    }
  }
  getSuggestions(query) {
    return [query];
  }
  renderSuggestion(value, el) {
    el.createDiv({ text: `${this.title}${value}` });
  }
  onChooseSuggestion(item, evt) {
    this.callback(item);
    this.callback = null;
  }
  onClose() {
    setTimeout(() => {
      if (this.callback != null) {
        this.callback(false);
      }
    }, 100);
  }
};

// TagFolderViewBase.ts
function toggleObjectProp(obj, propName, value) {
  if (value === false) {
    const newTagInfoEntries = Object.entries(obj || {}).filter(([key]) => key != propName);
    if (newTagInfoEntries.length == 0) {
      return {};
    } else {
      return Object.fromEntries(newTagInfoEntries);
    }
  } else {
    return { ...obj != null ? obj : {}, [propName]: value };
  }
}
var TagFolderViewBase = class extends import_obsidian5.ItemView {
  showOrder(evt) {
    const menu = new import_obsidian5.Menu();
    menu.addItem((item) => {
      item.setTitle("Tags").setIcon("hashtag").onClick(async (evt2) => {
        const menu2 = new import_obsidian5.Menu();
        for (const key in OrderKeyTag) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(
                OrderKeyTag[key] + " " + OrderDirection[direction]
              ).onClick(async () => {
                this.plugin.settings.sortTypeTag = newSetting;
                await this.plugin.saveSettings();
              });
              if (newSetting == this.plugin.settings.sortTypeTag) {
                item2.setIcon("checkmark");
              }
              return item2;
            });
          }
        }
        menu2.showAtPosition({ x: evt.x, y: evt.y });
      });
      return item;
    });
    menu.addItem((item) => {
      item.setTitle("Items").setIcon("document").onClick(async (evt2) => {
        const menu2 = new import_obsidian5.Menu();
        for (const key in OrderKeyItem) {
          for (const direction in OrderDirection) {
            menu2.addItem((item2) => {
              const newSetting = `${key}_${direction}`;
              item2.setTitle(
                OrderKeyItem[key] + " " + OrderDirection[direction]
              ).onClick(async () => {
                this.plugin.settings.sortType = newSetting;
                await this.plugin.saveSettings();
              });
              if (newSetting == this.plugin.settings.sortType) {
                item2.setIcon("checkmark");
              }
              return item2;
            });
          }
        }
        menu2.showAtPosition({ x: evt.x, y: evt.y });
      });
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showLevelSelect(evt) {
    const menu = new import_obsidian5.Menu();
    const setLevel = async (level) => {
      this.plugin.settings.expandLimit = level;
      await this.plugin.saveSettings();
      maxDepth.set(level);
    };
    for (const level of [2, 3, 4, 5]) {
      menu.addItem((item) => {
        item.setTitle(`Level ${level - 1}`).onClick(() => {
          setLevel(level);
        });
        if (this.plugin.settings.expandLimit == level)
          item.setIcon("checkmark");
        return item;
      });
    }
    menu.addItem((item) => {
      item.setTitle("No limit").onClick(() => {
        setLevel(0);
      });
      if (this.plugin.settings.expandLimit == 0)
        item.setIcon("checkmark");
      return item;
    });
    menu.showAtMouseEvent(evt);
  }
  showMenu(evt, trail, targetTag, targetItems) {
    const expandedTagsAll = ancestorToLongestTag(ancestorToTags(joinPartialPath(removeIntermediatePath(trail)))).map((e) => trimTrailingSlash(e));
    const expandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => !isSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const displayExpandedTags = expandedTagsAll.map((e) => e.split("/").filter((ee) => renderSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const menu = new import_obsidian5.Menu();
    if (navigator && navigator.clipboard) {
      menu.addItem(
        (item) => item.setTitle(`Copy tags:${expandedTags}`).setIcon("hashtag").onClick(async () => {
          await navigator.clipboard.writeText(expandedTags);
          new import_obsidian5.Notice("Copied");
        })
      );
    }
    menu.addItem(
      (item) => item.setTitle(`New note ${targetTag ? "in here" : "as like this"}`).setIcon("create-new").onClick(async () => {
        const ww = await this.app.fileManager.createAndOpenMarkdownFile();
        await this.app.vault.append(ww, expandedTags);
      })
    );
    if (targetTag) {
      if (this.plugin.settings.useTagInfo && this.plugin.tagInfo != null) {
        const tag = targetTag;
        if (tag in this.plugin.tagInfo && "key" in this.plugin.tagInfo[tag]) {
          menu.addItem(
            (item) => item.setTitle(`Unpin`).setIcon("pin").onClick(async () => {
              this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "key", false);
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            })
          );
        } else {
          menu.addItem((item) => {
            item.setTitle(`Pin`).setIcon("pin").onClick(async () => {
              this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "key", "");
              this.plugin.applyTagInfo();
              await this.plugin.saveTagInfo();
            });
          });
        }
        menu.addItem((item) => {
          item.setTitle(`Set an alternative label`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldAlt = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].alt) != null ? _a : "" : "";
            const label = await askString(this.app, "", "", oldAlt);
            if (label === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "alt", label == "" ? false : label);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Change the mark`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldMark = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].mark) != null ? _a : "" : "";
            const mark = await askString(this.app, "", "", oldMark);
            if (mark === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "mark", mark == "" ? false : mark);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        menu.addItem((item) => {
          item.setTitle(`Redirect this tag to ...`).setIcon("pencil").onClick(async () => {
            var _a;
            const oldRedirect = tag in this.plugin.tagInfo ? (_a = this.plugin.tagInfo[tag].redirect) != null ? _a : "" : "";
            const redirect = await askString(this.app, "", "", oldRedirect);
            if (redirect === false)
              return;
            this.plugin.tagInfo[tag] = toggleObjectProp(this.plugin.tagInfo[tag], "redirect", redirect == "" ? false : redirect);
            this.plugin.applyTagInfo();
            await this.plugin.saveTagInfo();
          });
        });
        if (targetItems) {
          menu.addItem((item) => {
            item.setTitle(`Open scroll view`).setIcon("sheets-in-box").onClick(async () => {
              const files = targetItems.map((e) => e.path);
              await this.plugin.openScrollView(null, displayExpandedTags, expandedTagsAll.join(", "), files);
            });
          });
          menu.addItem((item) => {
            item.setTitle(`Open list`).setIcon("sheets-in-box").onClick(async () => {
              selectedTags.set(
                expandedTagsAll
              );
            });
          });
        }
      }
    }
    if (!targetTag && targetItems && targetItems.length == 1) {
      const path = targetItems[0].path;
      const file = this.app.vault.getAbstractFileByPath(path);
      this.app.workspace.trigger(
        "file-menu",
        menu,
        file,
        "file-explorer"
      );
    }
    if (!targetTag && targetItems && targetItems.length == 1) {
      const path = targetItems[0].path;
      menu.addSeparator();
      menu.addItem(
        (item) => item.setTitle(`Open in new tab`).setIcon("lucide-file-plus").onClick(async () => {
          app.workspace.openLinkText(path, path, "tab");
        })
      );
      menu.addItem(
        (item) => item.setTitle(`Open to the right`).setIcon("lucide-separator-vertical").onClick(async () => {
          app.workspace.openLinkText(path, path, "split");
        })
      );
    }
    if ("screenX" in evt) {
      menu.showAtPosition({ x: evt.pageX, y: evt.pageY });
    } else {
      menu.showAtPosition({
        // @ts-ignore
        x: evt.nativeEvent.locationX,
        // @ts-ignore
        y: evt.nativeEvent.locationY
      });
    }
    evt.preventDefault();
  }
  switchView() {
    const viewType = this.getViewType() == VIEW_TYPE_TAGFOLDER ? VIEW_TYPE_TAGFOLDER_LIST : VIEW_TYPE_TAGFOLDER;
    const leaves = this.app.workspace.getLeavesOfType(viewType).filter((e) => !e.getViewState().pinned && e != this.leaf);
    if (leaves.length) {
      this.app.workspace.revealLeaf(
        leaves[0]
      );
    }
  }
};

// TagFolderView.ts
var TagFolderView = class extends TagFolderViewBase {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
  }
  getIcon() {
    return "stacked-levels";
  }
  newNote(evt) {
    this.app.commands.executeCommandById("file-explorer:new-file");
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER;
  }
  getDisplayText() {
    return "Tag Folder";
  }
  async onOpen() {
    this.containerEl.empty();
    this.component = new TagFolderViewComponent_default({
      target: this.containerEl,
      props: {
        openFile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        vaultName: this.app.vault.getName(),
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// TagFolderList.ts
var TagFolderList = class extends TagFolderViewBase {
  constructor(leaf, plugin) {
    super(leaf);
    this.state = { tags: [], title: "" };
    this.plugin = plugin;
    this.showMenu = this.showMenu.bind(this);
    this.showOrder = this.showOrder.bind(this);
    this.newNote = this.newNote.bind(this);
    this.showLevelSelect = this.showLevelSelect.bind(this);
    this.switchView = this.switchView.bind(this);
  }
  onPaneMenu(menu, source) {
    super.onPaneMenu(menu, source);
    menu.addItem((item) => {
      item.setIcon("pin").setTitle("Pin").onClick(() => {
        this.leaf.togglePinned();
      });
    });
  }
  getIcon() {
    return "stacked-levels";
  }
  async setState(state, result) {
    var _a;
    this.state = { ...state };
    this.title = state.tags.join(",");
    this.component.$set({ tags: state.tags, title: (_a = state.title) != null ? _a : "" });
    result = {};
    return;
  }
  getState() {
    return this.state;
  }
  async newNote(evt) {
    const expandedTags = this.state.tags.map((e) => trimTrailingSlash(e)).map((e) => e.split("/").filter((ee) => !isSpecialTag(ee)).join("/")).filter((e) => e != "").map((e) => "#" + e).join(" ").trim();
    const ww = await this.app.fileManager.createAndOpenMarkdownFile();
    await this.app.vault.append(ww, expandedTags);
  }
  getViewType() {
    return VIEW_TYPE_TAGFOLDER_LIST;
  }
  getDisplayText() {
    return `Files with ${this.state.title}`;
  }
  async onOpen() {
    this.containerEl.empty();
    this.component = new TagFolderViewComponent_default({
      target: this.containerEl,
      props: {
        openFile: this.plugin.focusFile,
        hoverPreview: this.plugin.hoverPreview,
        title: "",
        showMenu: this.showMenu,
        showLevelSelect: this.showLevelSelect,
        showOrder: this.showOrder,
        newNote: this.newNote,
        openScrollView: this.plugin.openScrollView,
        isViewSwitchable: this.plugin.settings.useMultiPaneList,
        switchView: this.switchView
      }
    });
  }
  async onClose() {
    if (this.component) {
      this.component.$destroy();
    }
  }
};

// main.ts
var HideItemsType = {
  NONE: "Hide nothing",
  DEDICATED_INTERMIDIATES: "Only intermediates of nested tags",
  ALL_EXCEPT_BOTTOM: "All intermediates"
};
function dotted(object, notation) {
  return notation.split(".").reduce((a, b) => a && b in a ? a[b] : null, object);
}
function getCompareMethodItems(settings) {
  const invert = settings.sortType.contains("_DESC") ? -1 : 1;
  switch (settings.sortType) {
    case "DISPNAME_ASC":
    case "DISPNAME_DESC":
      return (a, b) => compare(a.displayName, b.displayName) * invert;
    case "FULLPATH_ASC":
    case "FULLPATH_DESC":
      return (a, b) => compare(a.path, b.path) * invert;
    case "MTIME_ASC":
    case "MTIME_DESC":
      return (a, b) => (a.mtime - b.mtime) * invert;
    case "CTIME_ASC":
    case "CTIME_DESC":
      return (a, b) => (a.ctime - b.ctime) * invert;
    case "NAME_ASC":
    case "NAME_DESC":
      return (a, b) => compare(a.filename, b.filename) * invert;
    default:
      console.warn("Compare method (items) corrupted");
      return (a, b) => compare(a.displayName, b.displayName) * invert;
  }
}
function onElement(el, event, selector, callback, options) {
  el.on(event, selector, callback, options);
  return () => el.off(event, selector, callback, options);
}
var TagFolderPlugin = class extends import_obsidian6.Plugin {
  constructor() {
    super(...arguments);
    // Folder opening status.
    this.expandedFolders = ["root"];
    // The File that now opening
    this.currentOpeningFile = "";
    this.searchString = "";
    this.allViewItems = [];
    // Called when item clicked in the tag folder pane.
    this.focusFile = (path, specialKey) => {
      const targetFile = this.app.vault.getFiles().find((f) => f.path === path);
      if (targetFile) {
        if (specialKey) {
          app.workspace.openLinkText(targetFile.path, targetFile.path, "split");
        } else {
          app.workspace.openLinkText(targetFile.path, targetFile.path);
        }
      }
    };
    this.fileCaches = [];
    this.oldFileCache = "";
    this.lastSettings = "";
    this.lastSearchString = "";
    this.tagInfo = null;
    this.tagInfoFrontMatterBuffer = {};
    this.tagInfoBody = "";
  }
  getView() {
    for (const leaf of this.app.workspace.getLeavesOfType(
      VIEW_TYPE_TAGFOLDER
    )) {
      const view = leaf.view;
      if (view instanceof TagFolderView) {
        return view;
      }
    }
    return null;
  }
  hoverPreview(e, path) {
    this.app.workspace.trigger("hover-link", {
      event: e,
      source: "file-explorer",
      hoverParent: this,
      targetEl: e.target,
      linktext: path
    });
  }
  setSearchString(search) {
    searchString.set(search);
  }
  getFileTitle(file) {
    if (!this.settings.useTitle)
      return file.basename;
    const metadata = this.app.metadataCache.getCache(file.path);
    if (metadata.frontmatter && this.settings.frontmatterKey) {
      const d = dotted(metadata.frontmatter, this.settings.frontmatterKey);
      if (d)
        return d;
    }
    if (metadata.headings) {
      const h1 = metadata.headings.find((e) => e.level == 1);
      if (h1) {
        return h1.heading;
      }
    }
    return file.basename;
  }
  getDisplayName(file) {
    const filename = this.getFileTitle(file) || file.basename;
    if (this.settings.displayMethod == "NAME") {
      return filename;
    }
    const path = file.path.split("/");
    path.pop();
    const displayPath = path.join("/");
    if (this.settings.displayMethod == "NAME : PATH") {
      return `${filename} : ${displayPath}`;
    }
    if (this.settings.displayMethod == "PATH/NAME") {
      return `${displayPath}/${filename}`;
    }
    return filename;
  }
  async onload() {
    await this.loadSettings();
    this.hoverPreview = this.hoverPreview.bind(this);
    this.modifyFile = this.modifyFile.bind(this);
    this.setSearchString = this.setSearchString.bind(this);
    this.openScrollView = this.openScrollView.bind(this);
    this.loadFileInfo = (0, import_obsidian6.debounce)(
      this.loadFileInfo.bind(this),
      this.settings.scanDelay,
      true
    );
    this.registerView(
      VIEW_TYPE_TAGFOLDER,
      (leaf) => new TagFolderView(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_TAGFOLDER_LIST,
      (leaf) => new TagFolderList(leaf, this)
    );
    this.registerView(
      VIEW_TYPE_SCROLL,
      (leaf) => new ScrollView(leaf, this)
    );
    this.app.workspace.onLayoutReady(async () => {
      await this.initView();
      if (this.settings.alwaysOpen) {
        await this.activateView();
      }
    });
    this.addCommand({
      id: "tagfolder-open",
      name: "Show Tag Folder",
      callback: () => {
        this.activateView();
      }
    });
    this.addCommand({
      id: "tagfolder-create-similar",
      name: "Create a new note with the same tags",
      editorCallback: async (editor, view) => {
        const tags = (0, import_obsidian6.getAllTags)(this.app.metadataCache.getFileCache(view.file));
        const ww = await this.app.fileManager.createAndOpenMarkdownFile();
        await this.app.vault.append(ww, tags.join(" "));
      }
    });
    this.metadataCacheChanged = this.metadataCacheChanged.bind(this);
    this.watchWorkspaceOpen = this.watchWorkspaceOpen.bind(this);
    this.registerEvent(
      this.app.metadataCache.on("changed", this.metadataCacheChanged)
    );
    this.refreshAllTree = this.refreshAllTree.bind(this);
    this.registerEvent(this.app.vault.on("rename", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("delete", this.refreshAllTree));
    this.registerEvent(this.app.vault.on("modify", this.modifyFile));
    this.registerEvent(
      this.app.workspace.on("file-open", this.watchWorkspaceOpen)
    );
    this.watchWorkspaceOpen(this.app.workspace.getActiveFile());
    this.addSettingTab(new TagFolderSettingTab(this.app, this));
    maxDepth.set(this.settings.expandLimit);
    if (this.settings.useTagInfo) {
      this.app.workspace.onLayoutReady(async () => {
        await this.loadTagInfo();
      });
    }
    searchString.subscribe((search) => {
      this.searchString = search;
      this.refreshAllTree(null);
    });
    const setTagSearchString = (event, tagString) => {
      if (tagString) {
        const regExpTagStr = new RegExp(`(^|\\s)${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u");
        const regExpTagStrInv = new RegExp(`(^|\\s)-${tagString.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}(\\s|$)`, "u");
        if (event.altKey) {
          return;
        } else if (event.ctrlKey && event.shiftKey) {
          if (this.searchString.match(regExpTagStr)) {
            this.setSearchString(this.searchString.replace(regExpTagStr, ""));
          } else if (!this.searchString.match(regExpTagStrInv)) {
            this.setSearchString(this.searchString + (this.searchString.length == 0 ? "" : " ") + `-${tagString}`);
          }
        } else if (event.ctrlKey) {
          if (this.searchString.match(regExpTagStrInv)) {
            this.setSearchString(this.searchString.replace(regExpTagStrInv, ""));
          } else if (!this.searchString.match(regExpTagStr)) {
            this.setSearchString(this.searchString + (this.searchString.length == 0 ? "" : " ") + `${tagString}`);
          }
        } else {
          this.setSearchString(tagString);
        }
        event.preventDefault();
        event.stopPropagation();
      }
    };
    const selectorHashTagLink = 'a.tag[href^="#"]';
    const selectorHashTagSpan = "span.cm-hashtag.cm-meta";
    this.register(
      onElement(document, "click", selectorHashTagLink, (event, targetEl) => {
        if (!this.settings.overrideTagClicking)
          return;
        const tagString = targetEl.innerText.substring(1);
        if (tagString) {
          setTagSearchString(event, tagString);
        }
      }, { capture: true })
    );
    this.register(
      onElement(document, "click", selectorHashTagSpan, (event, targetEl) => {
        if (!this.settings.overrideTagClicking)
          return;
        let enumTags = targetEl;
        let tagString = "";
        while (!enumTags.classList.contains("cm-hashtag-begin")) {
          enumTags = enumTags.previousElementSibling;
          if (!enumTags) {
            console.log("Error! start tag not found.");
            return;
          }
        }
        do {
          if (enumTags instanceof HTMLElement) {
            tagString += enumTags.innerText;
            if (enumTags.classList.contains("cm-hashtag-end")) {
              break;
            }
          }
          enumTags = enumTags.nextElementSibling;
        } while (enumTags);
        tagString = tagString.substring(1);
        setTagSearchString(event, tagString);
      }, { capture: true })
    );
    selectedTags.subscribe((newTags) => {
      this.openListView(newTags);
    });
  }
  watchWorkspaceOpen(file) {
    if (file) {
      this.currentOpeningFile = file.path;
    } else {
      this.currentOpeningFile = "";
    }
    currentFile.set(this.currentOpeningFile);
  }
  metadataCacheChanged(file) {
    this.loadFileInfo(file);
  }
  refreshAllTree(file) {
    this.loadFileInfo();
  }
  updateFileCaches(diff) {
    if (this.fileCaches.length == 0 || !diff) {
      const files = [...this.app.vault.getMarkdownFiles(), ...this.app.vault.getAllLoadedFiles().filter((e) => "extension" in e && e.extension == "canvas")];
      this.fileCaches = files.map((fileEntry) => {
        return {
          file: fileEntry,
          metadata: this.app.metadataCache.getFileCache(fileEntry)
        };
      });
    } else {
      this.fileCaches = this.fileCaches.filter(
        (fileCache) => fileCache.file.path != diff.path
      );
      this.fileCaches.push({
        file: diff,
        metadata: this.app.metadataCache.getFileCache(diff)
      });
    }
    const fileCacheDump = JSON.stringify(
      this.fileCaches.map((e) => ({
        path: e.file.path,
        tags: (0, import_obsidian6.getAllTags)(e.metadata)
      }))
    );
    if (this.oldFileCache == fileCacheDump) {
      return false;
    } else {
      this.oldFileCache = fileCacheDump;
      return true;
    }
  }
  async getItemsList() {
    var _a;
    const items = [];
    const ignoreDocTags = this.settings.ignoreDocTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    const ignoreTags = this.settings.ignoreTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    const ignoreFolders = this.settings.ignoreFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const targetFolders = this.settings.targetFolders.toLocaleLowerCase().replace(/\n/g, "").split(",").map((e) => e.trim()).filter((e) => !!e);
    const searchItems = this.searchString.toLocaleLowerCase().split("|").map((ee) => ee.split(" ").map((e) => e.trim()));
    const today = Date.now();
    const archiveTags = this.settings.archiveTags.toLocaleLowerCase().replace(/[\n ]/g, "").split(",");
    for (const fileCache of this.fileCaches) {
      if (targetFolders.length > 0 && !targetFolders.some(
        (e) => {
          return e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e);
        }
      )) {
        continue;
      }
      if (ignoreFolders.some(
        (e) => e != "" && fileCache.file.path.toLocaleLowerCase().startsWith(e)
      )) {
        continue;
      }
      await doEvents();
      const tagRedirectList = {};
      if (this.settings.useTagInfo && this.tagInfo) {
        for (const [key, taginfo] of Object.entries(this.tagInfo)) {
          if ("redirect" in taginfo) {
            tagRedirectList[key] = taginfo.redirect;
          }
        }
      }
      const allTagsDocs = unique((_a = (0, import_obsidian6.getAllTags)(fileCache.metadata)) != null ? _a : []);
      let allTags = unique(allTagsDocs.map((e) => e.substring(1)).map((e) => e in tagRedirectList ? tagRedirectList[e] : e));
      if (this.settings.disableNestedTags) {
        allTags = allTags.map((e) => e.split("/")).flat();
      }
      if (allTags.length == 0) {
        allTags = ["_untagged"];
      }
      if (fileCache.file.extension == "canvas") {
        allTags.push("_VIRTUAL_TAG_CANVAS");
      }
      if (this.settings.useVirtualTag) {
        const mtime = fileCache.file.stat.mtime;
        const diff = today - mtime;
        const disp = secondsToFreshness(diff);
        allTags.push(`_VIRTUAL_TAG_FRESHNESS/${disp}`);
      }
      if (allTags.some(
        (tag) => ignoreDocTags.contains(tag.toLocaleLowerCase())
      )) {
        continue;
      }
      const w = searchItems.map((searchItem) => {
        let bx = false;
        if (allTags.length == 0)
          return false;
        for (const search of searchItem) {
          if (search.startsWith("-")) {
            bx = bx || allTags.some(
              (tag) => tag.toLocaleLowerCase().contains(search.substring(1))
            );
          } else {
            bx = bx || allTags.every(
              (tag) => !tag.toLocaleLowerCase().contains(search)
            );
          }
        }
        return bx;
      });
      if (w.every((e) => e))
        continue;
      allTags = allTags.filter(
        (tag) => !ignoreTags.contains(tag.toLocaleLowerCase())
      );
      if (this.settings.disableNarrowingDown) {
        const archiveTagsMatched = allTags.filter((e) => archiveTags.contains(e.toLocaleLowerCase()));
        const targetTags = archiveTagsMatched.length == 0 ? allTags : archiveTagsMatched;
        for (const tags of targetTags) {
          items.push({
            tags: [tags],
            extraTags: allTags.filter((e) => e != tags),
            path: fileCache.file.path,
            displayName: this.getDisplayName(fileCache.file),
            ancestors: [],
            mtime: fileCache.file.stat.mtime,
            ctime: fileCache.file.stat.ctime,
            filename: fileCache.file.basename
          });
        }
      } else {
        items.push({
          tags: allTags,
          extraTags: [],
          path: fileCache.file.path,
          displayName: this.getDisplayName(fileCache.file),
          ancestors: [],
          mtime: fileCache.file.stat.mtime,
          ctime: fileCache.file.stat.ctime,
          filename: fileCache.file.basename
        });
      }
    }
    return items;
  }
  loadFileInfo(diff) {
    this.loadFileInfoAsync(diff).then((e) => {
    });
  }
  // Sweep updated file or all files to retrieve tags.
  async loadFileInfoAsync(diff) {
    if (this.getView() == null)
      return;
    const strSetting = JSON.stringify(this.settings);
    const isSettingChanged = strSetting != this.lastSettings;
    const isSearchStringModified = this.searchString != this.lastSearchString;
    if (isSettingChanged) {
      this.lastSettings = strSetting;
    }
    if (isSearchStringModified) {
      this.lastSearchString = this.searchString;
    }
    if (!this.updateFileCaches(diff) && !isSearchStringModified && !isSettingChanged) {
      await this.applyUpdateIntoScroll(diff);
      return;
    }
    const items = await this.getItemsList();
    const itemsSorted = items.sort(this.compareItems);
    this.allViewItems = itemsSorted;
    allViewItems.set(this.allViewItems);
    await this.applyUpdateIntoScroll(diff);
  }
  onunload() {
  }
  async openScrollView(leaf, title, tagPath, files) {
    if (!leaf) {
      leaf = this.app.workspace.getLeaf("split");
    }
    await leaf.setViewState({
      type: VIEW_TYPE_SCROLL,
      active: true,
      state: { files: files.map((e) => ({ path: e })), title, tagPath }
    });
    this.app.workspace.revealLeaf(
      leaf
    );
  }
  async applyUpdateIntoScroll(file) {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_SCROLL);
    for (const leaf of leaves) {
      const view = leaf.view;
      if (!view)
        continue;
      const viewState = leaf.getViewState();
      const scrollViewState = view == null ? void 0 : view.getScrollViewState();
      if (!viewState || !scrollViewState)
        continue;
      const viewStat = { ...viewState, state: { ...scrollViewState } };
      if (file && view.isFileOpened(file.path)) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: viewStat.state.files.map((e) => e.path == file.path ? {
              path: file.path
            } : e)
          }
        };
        await leaf.setViewState(newStat);
      }
      const tagPath = viewStat.state.tagPath;
      const tags = tagPath.split(", ");
      let matchedFiles = this.allViewItems;
      for (const tag of tags) {
        matchedFiles = matchedFiles.filter(
          (item) => item.tags.map((tag2) => tag2.toLocaleLowerCase()).some(
            (itemTag) => itemTag == tag.toLocaleLowerCase() || (itemTag + "/").startsWith(
              tag.toLocaleLowerCase() + (tag.endsWith("/") ? "" : "/")
            )
          )
        );
      }
      const newFilesArray = matchedFiles.map((e) => e.path);
      const newFiles = newFilesArray.sort().join("-");
      const oldFiles = viewStat.state.files.map((e) => e.path).sort().join("-");
      if (newFiles != oldFiles) {
        const newStat = {
          ...viewStat,
          state: {
            ...viewStat.state,
            files: newFilesArray.map((path) => {
              const old = viewStat.state.files.find((e) => e.path == path);
              if (old)
                return old;
              return {
                path
              };
            })
          }
        };
        await leaf.setViewState(newStat);
      }
    }
  }
  async initView() {
    this.loadFileInfo();
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER);
    if (leaves.length == 0) {
      await this.app.workspace.getLeftLeaf(false).setViewState({
        type: VIEW_TYPE_TAGFOLDER
      });
    } else {
      leaves[0].setViewState({
        type: VIEW_TYPE_TAGFOLDER
      });
    }
  }
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER);
    await this.initView();
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(
        leaves[0]
      );
    }
  }
  async modifyFile(file) {
    if (!this.settings.useTagInfo)
      return;
    if (this.skipOnce) {
      this.skipOnce = false;
      return;
    }
    if (file.name == this.getTagInfoFilename()) {
      await this.loadTagInfo();
    }
  }
  getTagInfoFilename() {
    return (0, import_obsidian6.normalizePath)(this.settings.tagInfo);
  }
  getTagInfoFile() {
    const file = this.app.vault.getAbstractFileByPath(this.getTagInfoFilename());
    if (file instanceof import_obsidian6.TFile) {
      return file;
    }
    return null;
  }
  applyTagInfo() {
    if (this.tagInfo == null)
      return;
    if (!this.settings.useTagInfo)
      return;
    tagInfo.set(this.tagInfo);
  }
  async loadTagInfo() {
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      this.tagInfo = {};
    const file = this.getTagInfoFile();
    if (file == null)
      return;
    const data = await this.app.vault.read(file);
    try {
      const bodyStartIndex = data.indexOf("\n---");
      if (!data.startsWith("---") || bodyStartIndex === -1) {
        return;
      }
      const yaml = data.substring(3, bodyStartIndex);
      const yamlData = (0, import_obsidian6.parseYaml)(yaml);
      const keys = Object.keys(yamlData);
      this.tagInfoBody = data.substring(bodyStartIndex + 5);
      this.tagInfoFrontMatterBuffer = yamlData;
      const newTagInfo = {};
      for (const key of keys) {
        const w = yamlData[key];
        if (!w)
          continue;
        if (typeof w != "object")
          continue;
        const keys2 = ["key", "mark", "alt", "redirect"];
        const entries = Object.entries(w).filter(([key2]) => keys2.some((e) => key2.contains(e)));
        if (entries.length == 0)
          continue;
        newTagInfo[key] = Object.fromEntries(entries);
      }
      this.tagInfo = newTagInfo;
      this.applyTagInfo();
    } catch (ex) {
      console.log(ex);
    }
  }
  async saveTagInfo() {
    if (!this.settings.useTagInfo)
      return;
    if (this.tagInfo == null)
      return;
    let file = this.getTagInfoFile();
    if (file == null) {
      file = await this.app.vault.create(this.getTagInfoFilename(), "");
    }
    await app.fileManager.processFrontMatter(file, (matter) => {
      const ti = Object.entries(this.tagInfo);
      for (const [key, value] of ti) {
        if (value === void 0) {
          delete matter[key];
        } else {
          matter[key] = value;
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
    await this.loadTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
  }
  async saveSettings() {
    await this.saveData(this.settings);
    await this.saveTagInfo();
    tagFolderSetting.set(this.settings);
    this.compareItems = getCompareMethodItems(this.settings);
    if (this.allViewItems) {
      this.allViewItems = this.allViewItems.sort(this.compareItems);
      allViewItems.set(this.allViewItems);
    }
  }
  async openListView(tagSrc) {
    var _a;
    if (!tagSrc)
      return;
    const tags = tagSrc.first() == "root" ? tagSrc.slice(1) : tagSrc;
    let theLeaf;
    for (const leaf of this.app.workspace.getLeavesOfType(
      VIEW_TYPE_TAGFOLDER_LIST
    )) {
      const state = leaf.getViewState();
      if (state.state.tags.slice().sort().join("-") == tags.slice().sort().join("-")) {
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
        return;
      }
      if (state.pinned) {
      } else {
        theLeaf = leaf;
      }
    }
    if (!theLeaf) {
      const parent = (_a = this.app.workspace.getLeavesOfType(VIEW_TYPE_TAGFOLDER)) == null ? void 0 : _a.first();
      if (!parent) {
        return;
      }
      if (!import_obsidian6.Platform.isMobile) {
        theLeaf = this.app.workspace.createLeafBySplit(parent, "horizontal", false);
      } else {
        theLeaf = this.app.workspace.getLeftLeaf(false);
      }
    }
    const title = tags.map(
      (e) => e.split("/").map((ee) => renderSpecialTag(ee)).join("/")
    ).join(" ");
    await theLeaf.setViewState({
      type: VIEW_TYPE_TAGFOLDER_LIST,
      active: true,
      state: { tags, title }
    });
    this.app.workspace.revealLeaf(
      theLeaf
    );
  }
};
var TagFolderSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  hide() {
    this.plugin.loadFileInfo();
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Settings for TagFolder" });
    containerEl.createEl("h3", { text: "Behavior" });
    new import_obsidian6.Setting(containerEl).setName("Always Open").setDesc("Place TagFolder on the left pane and activate it at every Obsidian launch").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.alwaysOpen).onChange(async (value) => {
        this.plugin.settings.alwaysOpen = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Use pinning").setDesc(
      "When this feature is enabled, the pin information is saved in the file set in the next configuration."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTagInfo).onChange(async (value) => {
        this.plugin.settings.useTagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
        pi.setDisabled(!value);
      });
    });
    const pi = new import_obsidian6.Setting(containerEl).setName("Pin information file").setDisabled(!this.plugin.settings.useTagInfo).addText((text2) => {
      text2.setValue(this.plugin.settings.tagInfo).onChange(async (value) => {
        this.plugin.settings.tagInfo = value;
        if (this.plugin.settings.useTagInfo) {
          await this.plugin.loadTagInfo();
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Disable narrowing down").setDesc(
      "When this feature is enabled, relevant tags will be shown with the title instead of making a sub-structure."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNarrowingDown).onChange(async (value) => {
        this.plugin.settings.disableNarrowingDown = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Files" });
    new import_obsidian6.Setting(containerEl).setName("Display method").setDesc("How to show a title of files").addDropdown(
      (dropdown) => dropdown.addOptions({
        "PATH/NAME": "PATH/NAME",
        NAME: "NAME",
        "NAME : PATH": "NAME : PATH"
      }).setValue(this.plugin.settings.displayMethod).onChange(async (value) => {
        this.plugin.settings.displayMethod = value;
        this.plugin.loadFileInfo(null);
        await this.plugin.saveSettings();
      })
    );
    const setOrderMethod = async (key, order) => {
      const oldSetting = this.plugin.settings.sortType.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortType = `${key}_${order}`;
      await this.plugin.saveSettings();
    };
    new import_obsidian6.Setting(containerEl).setName("Order method").setDesc("how to order items").addDropdown((dd) => {
      dd.addOptions(OrderKeyItem).setValue(this.plugin.settings.sortType.split("_")[0]).onChange((key) => setOrderMethod(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortType.split("_")[1]).onChange((order) => setOrderMethod(null, order));
    });
    new import_obsidian6.Setting(containerEl).setName("Use title").setDesc(
      "Use value in the frontmatter or first level one heading for `NAME`."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useTitle).onChange(async (value) => {
        this.plugin.settings.useTitle = value;
        fpath.setDisabled(!value);
        await this.plugin.saveSettings();
      });
    });
    const fpath = new import_obsidian6.Setting(containerEl).setName("Frontmatter path").setDisabled(!this.plugin.settings.useTitle).addText((text2) => {
      text2.setValue(this.plugin.settings.frontmatterKey).onChange(async (value) => {
        this.plugin.settings.frontmatterKey = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Tags" });
    const setOrderMethodTag = async (key, order) => {
      const oldSetting = this.plugin.settings.sortTypeTag.split("_");
      if (!key)
        key = oldSetting[0];
      if (!order)
        order = oldSetting[1];
      this.plugin.settings.sortTypeTag = `${key}_${order}`;
      await this.plugin.saveSettings();
    };
    new import_obsidian6.Setting(containerEl).setName("Order method").setDesc("how to order tags").addDropdown((dd) => {
      dd.addOptions(OrderKeyTag).setValue(this.plugin.settings.sortTypeTag.split("_")[0]).onChange((key) => setOrderMethodTag(key, null));
    }).addDropdown((dd) => {
      dd.addOptions(OrderDirection).setValue(this.plugin.settings.sortTypeTag.split("_")[1]).onChange((order) => setOrderMethodTag(null, order));
    });
    new import_obsidian6.Setting(containerEl).setName("Use virtual tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useVirtualTag).onChange(async (value) => {
        this.plugin.settings.useVirtualTag = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Actions" });
    new import_obsidian6.Setting(containerEl).setName("Search tags inside TagFolder when clicking tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.overrideTagClicking).onChange(async (value) => {
        this.plugin.settings.overrideTagClicking = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("List files in a separated pane").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.useMultiPaneList).onChange(async (value) => {
        this.plugin.settings.useMultiPaneList = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Arrangements" });
    new import_obsidian6.Setting(containerEl).setName("Hide Items").setDesc("Hide items on the landing or nested tags").addDropdown((dd) => {
      dd.addOptions(HideItemsType).setValue(this.plugin.settings.hideItems).onChange(async (key) => {
        if (key == "NONE" || key == "DEDICATED_INTERMIDIATES" || key == "ALL_EXCEPT_BOTTOM") {
          this.plugin.settings.hideItems = key;
        }
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Merge redundant combinations").setDesc(
      "When this feature is enabled, a/b and b/a are merged into a/b if there is no intermediates."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.mergeRedundantCombination).onChange(async (value) => {
        this.plugin.settings.mergeRedundantCombination = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Do not simplify empty folders").setDesc(
      "Keep empty folders, even if they can be simplified."
    ).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.doNotSimplifyTags).onChange(async (value) => {
        this.plugin.settings.doNotSimplifyTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Do not treat nested tags as dedicated levels").setDesc("Treat nested tags as normal tags").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableNestedTags).onChange(async (value) => {
        this.plugin.settings.disableNestedTags = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Reduce duplicated parents in nested tags").setDesc("If enabled, #web/css, #web/javascript will merged into web -> css -> javascript").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.reduceNestedParent).onChange(async (value) => {
        this.plugin.settings.reduceNestedParent = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Keep untagged items on the root").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.expandUntaggedToRoot).onChange(async (value) => {
        this.plugin.settings.expandUntaggedToRoot = value;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h3", { text: "Filters" });
    new import_obsidian6.Setting(containerEl).setName("Target Folders").setDesc("If configured, the plugin will only target files in it.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.targetFolders).setPlaceholder("study,documents/summary").onChange(async (value) => {
        this.plugin.settings.targetFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore Folders").setDesc("Ignore documents in specific folders.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreFolders).setPlaceholder("template,list/standard_tags").onChange(async (value) => {
        this.plugin.settings.ignoreFolders = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore note Tag").setDesc(
      "If the note has the tag listed below, the note would be treated as there was not."
    ).addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreDocTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
        this.plugin.settings.ignoreDocTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Ignore Tag").setDesc("Tags in the list would be treated as there were not.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.ignoreTags).setPlaceholder("test,test1,test2").onChange(async (value) => {
        this.plugin.settings.ignoreTags = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Archive tags").setDesc("If configured, notes with these tags will be moved under the tag.").addTextArea(
      (text2) => text2.setValue(this.plugin.settings.archiveTags).setPlaceholder("archived, discontinued").onChange(async (value) => {
        this.plugin.settings.archiveTags = value;
        await this.plugin.saveSettings();
      })
    );
    containerEl.createEl("h3", { text: "Misc" });
    new import_obsidian6.Setting(containerEl).setName("Tag scanning delay").setDesc(
      "Sets the delay for reflecting metadata changes to the tag tree. (Plugin reload is required.)"
    ).addText((text2) => {
      text2 = text2.setValue(this.plugin.settings.scanDelay + "").onChange(async (value) => {
        const newDelay = Number.parseInt(value, 10);
        if (newDelay) {
          this.plugin.settings.scanDelay = newDelay;
          await this.plugin.saveSettings();
        }
      });
      text2.inputEl.setAttribute("type", "number");
      text2.inputEl.setAttribute("min", "250");
      return text2;
    });
    containerEl.createEl("h3", { text: "Utilities" });
    new import_obsidian6.Setting(containerEl).setName("Dumping tags for reporting bugs").setDesc(
      "If you want to open an issue to the GitHub, this information can be useful. and, also if you want to keep secrets about names of tags, you can use `disguised`."
    ).addButton((button) => button.setButtonText("Copy tags").setDisabled(false).onClick(async () => {
      const itemsAll = await this.plugin.getItemsList();
      const items = itemsAll.map((e) => e.tags.filter((e2) => e2 != "_untagged")).filter((e) => e.length);
      await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#${e2}`).join(", ")).join("\n"));
      new import_obsidian6.Notice("Copied to clipboard");
    })).addButton(
      (button) => button.setButtonText("Copy disguised tags").setDisabled(false).onClick(async () => {
        const x = /* @__PURE__ */ new Map();
        let i = 0;
        const itemsAll = await this.plugin.getItemsList();
        const items = itemsAll.map((e) => e.tags.filter((e2) => e2 != "_untagged").map((e2) => x.has(e2) ? x.get(e2) : (x.set(e2, i++), i))).filter((e) => e.length);
        await navigator.clipboard.writeText(items.map((e) => e.map((e2) => `#tag${e2}`).join(", ")).join("\n"));
        new import_obsidian6.Notice("Copied to clipboard");
      })
    );
  }
};
